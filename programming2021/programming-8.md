# 第7回　関数とモジュール

## 関数



## 名前空間

第4回「変数とメモリ」において、変数がオブジェクトに貼り付けられたラベルであるという話をしました。オブジェクトはメモリ上のある領域に格納されていることはすでに説明しました。一方、ラベルである「変数名」の方は、あるディクショナリのキーとして保存されています。

Pythonプログラムが実行されると、Pythonは、ある特別な辞書を作成します。これは、実行中のプログラムにおける変数名をキーとし、その変数名が指すオブジェクトを値とする辞書です。この辞書のことを、**グローバル名前空間**と呼ぶことがあります。グローバルという言葉には、「グローバル名前空間に登録されている変数は、どこからでも参照できる」という意味合いが込められています。

グローバル名前空間はビルトイン関数globals()の戻り値として得られます。

```python
>>> globals()
{'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': <class '_frozen_importlib.BuiltinImporter'>, '__spec__': None, '__annotations__': {}, '__builtins__': <module 'builtins' (built-in)>}
```

この出力を見ると、すでにPythonが幾つかの変数を定義ずみであることがわかります。たとえば__name__という変数は__main__という文字列として定義されています。

```python
>>> print(__name__)
__main__
```

注)__name__変数の意味は後で説明します。

さて、グローバル名前空間は、どのような変数が定義されているかをPythonに教えるために存在しています。ためしにxという変数を定義して、実際にそれがグローバル名前空間に追加されることを確認しましょう。

```python
>>> x = 1
>>> globals()
{'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': <class '_frozen_importlib.BuiltinImporter'>, '__spec__': None, '__annotations__': {}, '__builtins__': <module 'builtins' (built-in)>, 'x': 1}
```

逆に、グローバル名前空間辞書に新たなキー：値ペアを追加することで、変数が定義されるかどうか試してみましょう。

```python
>>> globals().update({'y':2})
>>> y
2
```

このように、変数を定義するということは、グローバル名前空間に新たなキー：値ペアを追加することを意味します。

たとえばprint(x)というコードを実行すると、Pythonは、globals()名前空間を検索して、キー'x'に対応する値である整数オブジェクト1を発見し、それを印字するということをしています。このように名前空間が存在するおかげで、Pythonは、変数名とオブジェクトを対応づけることができます。

## 関数とローカル名前空間

上述したように、グローバル名前空間に登録されている変数は、どこからでも参照できます。関数の中も例外ではありません。

```python
>>> x = 5
>>> def f():
...     print(x)
...
>>> f()
5
```

ただし、関数の中で定義された変数は、グローバル名前空間には登録されず、**ローカル名前空間**という別の名前空間に登録されます。ローカル名前空間は、関数の中でlocals()関数によって出力することができます。

```python
>>> def f():
...     x = 234
...     print(locals())
... 
>>> f()
{'x': 234}
```

グローバル名前空間に登録された変数をグローバル変数、ローカル名前空間に登録された変数をローカル変数と呼びます。もう一つ、**ビルトイン**という名前空間がありますが、それについては後述します。

|定義される場所|登録される名前空間|変数の呼び名|
|---|---|---|
|関数の外|グローバル名前空間|グローバル変数|
|関数の中|ローカル名前空間|ローカル変数|
|ビルトインモジュール|ビルトイン名前空間|ビルトイン変数|

実は、ローカル名前空間は辞書に見えるだけで、本当は**辞書ではありません**。locals()関数は、ローカル名前空間を辞書のフォーマットにしたものを返すだけで、ローカル名前空間そのものを返すわけではありません。これをあまり意識する必要はありませんが、locals()の戻り値は名前空間ではないので、そこに変数を登録しても、ローカル名前空間は**変化しない**ことに注意しましょう。

```python
>>> def f():
...     x = 123
...     locals()['x'] = 567
...     print(x)
...
>>> f()
123
```

この点に関しては、[Pythonドキュメンテーション](https://docs.python.org/3/library/functions.html)のビルトイン関数の解説に、はっきりと、「locals()の戻り値を修正すべきではない」と説明があります。

なお、ローカル名前空間は、関数が呼び出されている間だけしか存続せず、関数の外からはアクセスすることができません。

```python
>>> def f():
...     x = 234
... 
>>> f()
>>> print(x)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'x' is not defined
>>> 
```

## 入れ子のローカル名前空間

関数が入れ子になっているとき、外側の関数と内側の関数に別々のローカル名前空間が存在します。

## ビルトイン名前空間

最後に、ビルトイン名前空間について説明します。ビルトイン名前空間は、ビルトイン変数やビルトイン関数が定義されている名前空間で、ここに登録されている変数や関数は、やはりプログラムのどこからでも参照できるようになっています。

ビルトイン名前空間に登録されている変数をリストの形式で表示するには、次のコードを実行します。

```python
>>> dir(__builtins__)
['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning', 'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError', 'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning', 'EOFError', 'Ellipsis',  

(...中略...)

'int', 'isinstance', 'issubclass', 'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview', 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property', 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars', 'zip']
>>> len(dir(__builtins__))
155
```

上記のように、155のビルトイン変数/関数が定義されていることが分かります。ビルトイン名前空間は、変数/関数を参照するためだけに存在している名前空間ですから、ビルトイン名前空間に新たな変数を登録することは通常行いませんし、必要もありません。

関数の外（トップレベル）で代入操作を行うと、グローバル名前空間に変数が登録されるのであって、ビルトイン名前空間に変数名が登録されることはありません。

## 名前解決

さて、たとえば、

```python
print(x)
```

というコードがあったとき、Pythonのインタープリタは、xという変数名がどのオブジェクトを指しているのか特定しなくてはなりません。この作業を**名前解決**と呼びます。Pythonでの名前解決は次の順番に名前空間を探索することにより行われます。

1. ローカル名前空間(Local)
2. 外側の関数の名前空間(Enclosing)
3. グローバル名前空間(Global)
4. ビルトイン名前空間(Built-in)

このルールを**LEGBルール**と呼びます。

グローバル名前空間とローカル名前空間に同じ名前の変数が存在する場合、ローカル名前空間が優先されます。

```python
>>> x = 123
>>> def f():
...     x = 456
...     print(x)
...
>>> f()
456
```

関数の中においては、グローバル変数を参照できますが、グローバル変数への代入はできません。どうしても代入をしたい場合は、関数の最初に、global宣言子を使って、変数がグローバル変数であることを宣言します。

```python
>>> x = 123
>>> def f():
...     global x
...     x = 456
...
>>> f()
>>> print(x)
456
```

## モジュールの作成とインポート

**モジュール**という言葉には難しい意味合いはなく、「実行可能なPythonのファイル」とほとんど同じ意味です。とくに、別のPythonプログラムからインポートされる想定で作られたPythonファイルをモジュールと言うことが多いようです。それではまず、my_moduleという名前の空のモジュールを作ってみましょう。my_module.pyという名前のファイルを作って次の内容を保存しておきましょう。

```python
# my_moduleの中身
x = 123
```

次にこれを読み込みます。

```python
>>> import my_module
>>> print(my_module.x)
123
```

このように、モジュールを読み込むと、モジュール内で
