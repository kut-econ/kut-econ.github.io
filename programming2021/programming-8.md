# 第7回　関数とモジュール

- [第7回　関数とモジュール](#第7回関数とモジュール)
  - [関数](#関数)
  - [ジェネレータ](#ジェネレータ)
  - [内包表記](#内包表記)
  - [if/if-elseつき内包表記](#ifif-elseつき内包表記)
  - [モジュールの種類](#モジュールの種類)
    - [外部ファイル](#外部ファイル)
    - [ビルトインモジュール](#ビルトインモジュール)
    - [builtinsモジュール](#builtinsモジュール)
  - [mainモジュール](#mainモジュール)
  - [モジュールを作る](#モジュールを作る)
  - [モジュールのリロード](#モジュールのリロード)
  - [モジュールのバイトコード](#モジュールのバイトコード)
  - [名前空間](#名前空間)
  - [スコープ](#スコープ)
  - [関数とローカル名前空間](#関数とローカル名前空間)
  - [入れ子のローカル名前空間](#入れ子のローカル名前空間)
  - [ビルトイン名前空間](#ビルトイン名前空間)
  - [名前解決](#名前解決)
  - [モジュールの作成とインポート](#モジュールの作成とインポート)

## 関数

まずRにおける関数の作成を思い出しましょう。一例として、2つの引数の和を返すだけのmyadd関数を定義するには、次のように書くのでしたね。

```R
myadd <- function(a,b) {
    z <- a + b
    return(z)
}
```

上記において、関数の中身(ボディ)は、中括弧の中で与えられます。`a`、`b`が引数であり、任意の数値を想定しています。関数`return`を呼び出すことで関数の実行は終了し、returnの引数が戻り値として返されます。作成された関数は、無名のまま使うこともできますが、通常は何度も再利用するものです。そのため、`myadd`という名前(**識別子**)に、作成した関数オブジェクトを`<-`演算子によって付値しています。これにより、識別子myaddに関数オブジェクトが結び付けられ、次のようにこの関数を何度でも呼び出せるようになります。

```R
> res = myadd(2,8)
> print(res)
[1] 10
```

なお上記では、`return(a+b)`としても構いませんが、関数のボディの存在をわかりやすくするために、あえて複数行で記述しました。

一方、Pythonの関数は、以下の`def`命令を用いて作成し、必ず識別子への代入が行われます。(Pythonにも**lambda式**という無名関数はありますが、全く違う方法で作ります。残念ながらlambda式では複数行ブロックをもつ関数を作ることはできません。lambda式については教科書のセクション8.4.4に詳しく説明がありますのでよく読んでおいてください。)上記のRコードはPythonで書き直すと次のようになります。

```python
def myadd(a,b):
    z = a + b       # 関数ブロック
    return z        #

print(myadd(5,4))
print(myadd(10,-2))
```

```python
# 出力
9
8
```

ifブロックやforブロックと同じように、関数の内容もまた、インデントを用いたブロックによって表現します。戻り値は`return`命令で返します。Pythonのdefやdelとおなじような命令であって、関数ではないことに注意しましょう。したがって、returnにはカッコは必要ありません。

return命令を省略すると、関数はNoneオブジェクトを返します。Noneは「空っぽ」を意味するオブジェクトであり、メモリ上に常駐していて常に再利用されます。たとえば次の関数helloは、return命令を呼び出しませんので、その戻り値はNoneとなります。

```python
def hello():
    print('Hello, World!')

x = hello()
print(x is None)
```

```python
# 出力
Hello, World!
True
```

また、関数を終了させたいが、戻り値はいらないという場合は、単にreturnと書くと、Noneを返して終了します。何らかの理由で関数の実行を途中で終了したい場合に有用です。

```python
# %%
def hello(name):
    if name == '':
        print('hello,world!')
        return
    print('hello,' + name)

hello('')
hello('taro')
```

```python
# 出力
hello,world!
hello,taro
```

## ジェネレータ

`return`命令の代わりに`yield`命令を使うと、関数は**ジェネレータ関数**という特別な関数になります。ジェネレータ関数は、戻り値として、**ジェネレータオブジェクト**を返します。(ジェネレータ関数とジェネレータオブジェクトのどちらも**ジェネレータ**と呼ぶことがあるので注意してください。)

ジェネレータオブジェクトは、イテラブルなオブジェクトであり、主にループ処理で用いることができます。ループ処理でループインデックスに代入されるのは、yieldの戻り値です。ただし、注意しなくてはならないのは、yieldは作業を中断するだけで、関数ブロックの処理を終了しないということです。

たとえば、次のようなジェネレータは、10までの偶数を順番にループインデックスに返します。

```python
# %%
# ジェネレータ関数の定義
def yield_even():
    for i in range(20):
        if i%2 == 0:
            yield i

# ジェネレータの活用
for i in yield_even():
    print(i)
```

```python
# 出力
0
2
4
6
8
10
12
14
16
18
```

次に説明する**内包表記**を用いると、ジェネレータから簡単にリストを作成できます。

```python
def yield_even():
    for i in range(20):
        if i%2 == 0:
            yield i

# 内包表記
x = [i for i in yield_even()]
print(x)
```

```python
# 出力
[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
```

## 内包表記

脱線しますが、せっかくですので、ここで**内包表記**についてお話ししておきます。内包表記は、ループ処理の結果をリスト、辞書、集合などのコンテナ型オブジェクトにまとめるためのPython特有の構文であり、なれるとコードをコンパクトに書くのに非常に有用です。

```python
# リスト内包表記
[iの関数 for i in ループ範囲]
# セット(集合)内包表記
{iの関数 for i in ループ範囲}
# 辞書内包表記
{iの関数:iの関数　for i in ループ範囲}
```

例えば、100までの偶数の自乗をすべて収めたリストを作るときは、次のように書きます。

```python
>>> [i**2 for i in range(0,100,2)]
[0, 4, 16, 36, 64, 100, 144, 196, 256, 324, 400, 484, 576, 676, 784, 900, 1024, 1156, 1296, 1444, 1600, 1764, 1936, 2116, 2304, 2500, 2704, 2916, 3136, 3364, 3600, 3844, 4096, 4356, 4624, 4900, 5184, 5476, 5776, 6084, 6400, 6724, 7056, 7396, 7744, 8100, 8464, 8836, 9216, 9604]
```

同じことをforループでやるとすると、たとえば次のようになります。

```python
# %%
x = []
for i in range(0,100,2):
    x.append(i**2)

print(x)
```

セット内包表記は`[]`を`{}`にするだけですが、リストと違い重複を除去できます。次のコードは、100までの偶数の自乗を5で割った余りを集めたリストと集合を計算するためのものです。

```python
>>> [i**2 % 5 for i in range(0,100,2)]
[0, 4, 1, 1, 4, 0, 4, 1, 1, 4, 0, 4, 1, 1, 4, 0, 4, 1, 1, 4, 0, 4, 1, 1, 4, 0, 4, 1, 1, 4, 0, 4, 1, 1, 4, 0, 4, 1, 1, 4, 0, 4, 1, 1, 4, 0, 4, 1, 1, 4]
>>> {i**2 % 5 for i in range(0,100,2)}
{0, 1, 4}
```

辞書内包表記は少し特徴的です。たとえば次は、"hello,world!"という文字列のそれぞれの文字をキーとし、キーの大文字を値とする辞書を作成するコードです。やはりこの場合も、キーの重複は取り除かれます。

```python
>>> x = {c:c.upper() for c in "hello,world!"}
>>> x
{'h': 'H', 'e': 'E', 'l': 'L', 'o': 'O', ',': ',', 'w': 'W', 'r': 'R', 'd': 'D', '!': '!'}
```

辞書で内包表記でキーの重複が取り除かれる際には、最新の値が採用されるので注意が必要です。たとえば、次のコードは、キーと値を入れ替えた辞書を作るものです。値は一意とは限らないので、重複部分は除去され、最新のペアだけが残ります。

```python
# %%
x = {'foo':1,'bar':2,'baz':1}
{j:i for i,j in x.items()}
```

```python
# 出力
{1: 'baz', 2: 'bar'}
```

## if/if-elseつき内包表記

先に挙げた、100までの偶数の自乗を含むリストは、次のようにifと組み合わせた内包表記によっても作成できます。

```python
# %%
x = [i**2 for i in range(100) if i%2 ==0]
print(x)
```

```python
# 出力

[0, 4, 16, 36, 64, 100, 144, 196, 256, 324, 400, 484, 576, 676, 784, 900, 1024, 1156, 1296, 1444, 1600, 1764, 1936, 2116, 2304, 2500, 2704, 2916, 3136, 3364, 3600, 3844, 4096, 4356, 4624, 4900, 5184, 5476, 5776, 6084, 6400, 6724, 7056, 7396, 7744, 8100, 8464, 8836, 9216, 9604]
```

上記では、`i`が2で割り切れるときのみ`i**2`をリストに加える、という意味になります。

ところが、`i`が2で割り切れるときは`i**2`をリストに加え、そうでないときは0を加えよ、という命令にしたいときは、下のようにかなり異なる表現になります。

```python
# %%
x = [i**2 if i%2==0 else 0 for i in range(100)]
print(x)
```

実はこの表現においては、単文の**if-else**構文が使われています。単文のif-elseは次のように用います。

```python
式A if 条件 else 式B
```

このように書くと、「条件が成り立っていれば式A、さもなくば式B」という意味になります。本来内包表記とは直接関係がなく、どこでも用いることができます。たとえばxにiの絶対値を代入したい場合は次のように書くことができます。(実際には`abs`という絶対値を返すビルトイン関数があります。)

```python
x = i if i>=0 else -i
```

このように、ifつき内包表記とif-elseつき内包表記は全く別のものですので、両者を組み合わせることもできます(おすすめはしませんが)。たとえば、「5で割り切れる数のうち、偶数は自乗し、奇数は0で置き換えたリスト」は次のように表現できます。

```python
# %%
x = [i**2 if i%3==0 else i for i in range(100) if i%7==0]
print(x)
```

```python
# 出力

[0, 7, 14, 441, 28, 35, 1764, 49, 56, 3969, 70, 77, 7056, 91, 98]
```

このように、内包表記はかなり高い表現力をもっています。forループの結果をリストに格納したい、ということはプログラミングをやっていると頻発しますので、この機会にぜひ覚えておきましょう。

## モジュールの種類

さて、自作した関数を複数のプログラムで再利用したい場合には、モジュールの仕組みを活用するのが便利です。これまでにも、`sys`モジュールや`copy`モジュールを随所で活用してきましたが、ここでモジュールとはどのようなものかを明確にしておきましょう。

モジュールは、Pythonスクリプトから読み込んで使用できる関数や変数、データ型、Pythonコードの集合のことを広く指します。

Pythonには以下の4種類のモジュールがあります。

|種類|説明|例|
|--|--|--|
|外部ファイル|PythonやCで作成され、importで呼び出して使う|copy|
|ビルトインモジュール|インタープリタに組み込まれ、importで呼び出して使う(`builtins`モジュールは例外)|sys|
|`builtins`|特別なビルトインモジュールで、起動時に自動で読み込まれている|builtins|
|`main`モジュール|主スクリプトの属するモジュール|任意のスクリプト|

![module_types](img/module_types.drawio.png)

### 外部ファイル

全てのPythonスクリプトは他のPythonスクリプトに`import`命令で読み込めるので、モジュールとして機能します。その他にも、たとえばCPythonインタープリタであれば、C言語やCythonと言った言語でモジュールを作成できます。こういった外部ファイルで提供されたモジュールは、import命令によって主プログラムに読み込んで使用することができます。たとえば`copy`モジュールはcopy.pyというPythonスクリプトとして存在しており、import命令で読み込めます。

### ビルトインモジュール

それに対して、ファイルの形では存在していないビルトインモジュールという特別なタイプのモジュールがあります。たとえば`sys`はビルトインモジュールであり、インタープリタに埋め込まれています。こういったものもimport文で読み込んで使うことができます。

importしたモジュールがビルトインかどうかは単にそのオブジェクトをprintしてみればわかります。

```python
>>> import sys
>>> print(sys)
<module 'sys' (built-in)>
>>> import copy
>>> print(copy)
<module 'copy' from '/usr/lib/python3.8/copy.py'>
```

ビルトインモジュールの場合は、`sys`のように`(built-in)`と表示されます。一方、ファイルの場合は、`copy`のようにモジュールファイルのある場所が表示されます。

### builtinsモジュール

ビルトインモジュールの中には、ただ一つだけ`builtins`という特別なモジュールがあります。これは、たとえば`print`など、最初から使える関数や値を定義しているモジュールです。builtinsだけは、importを必要とせず、`__builtins__`という別名でPythonの起動と同時に自動的に読み込まれます。試しに、`__builtins__`をprintしてみてください。

```python
>>> print(__builtins__)
<module 'builtins' (built-in)>
```

このように、`__builtins__`という名前がすでに定義されていて、その正体は`builtins`というビルトインモジュールであることがわかります(とてもややこしいので混乱しないように注意してください)。これは、`builtins`モジュールが`__builtins__`という別名で読み込まれているということを意味します。モジュールの別名読み込みは一般に次のようなimport-as文で行います。

```python
import モジュール名 as 別名
```

つまり、builtinsモジュールだけは、起動時に次のように読み込まれたのと同じ状態になるということです。

```python
import builtins as __builtins__
```

なぜこのようになっているかというのは、名前空間の節で説明します。

## mainモジュール

最後に、**main**というモジュールがあります(正確には`__main__`)。これは、実行時の主スクリプトの別名です。たとえばコマンドプロンプトで次のようにfile.pyスクリプトを実行したとします。

```cmd
python file.py
```

このとき、file.pyに記述された変数、関数、コード、データ型は全て`main`モジュールに属することになります。

このように、Pythonスクリプトは全てモジュールとして機能しますが、その逆は必ずしも成り立ちません。モジュールはスクリプトよりも広い概念です。

## モジュールを作る

それでは折角ですので、モジュールを自作してみましょう。といっても、二つのPythonスクリプトを作成し、一方をもう一方からimportするだけです。importする側がmainモジュールとなります。

GitHubディレクトリの中にmy_first_moduleというフォルダを作ってVS Codeで開きましょう。そして、mymod1.pyというファイルを作って開きましょう。この中に、次のように記述します。

```python
x = 5
def hello():
    print("Hello,World!")
```

記述を終えたら保存します。ここでの目的は、mymod1.pyの中で定義された変数`x`と関数`hello`を再利用することです。

次に、mymain.pyというファイルを作成して開き、次のように記述して**インタラクティブモード**で実行してみましょう。

```python
# %%
import mymod1

print(mymod1.x)
mymod1.hello()
```

ここで、`mymod1.x`によって、mymod1.pyで定義された変数xにアクセスしていることに注意してください。上手くimportできれば、次のように表示されるはずです。

```python
# 出力
5
Hello,World!
```

ここで2点注意事項があります。

1. `import`での読み込みは初回のみ有効であり、モジュールの再読み込み(リロード)には使えない。
2. 一度読み込まれたモジュールはバイトコンパイルされ、変更がない限り再利用され続ける。

## モジュールのリロード

上記1は、モジュールを変更したら、一旦Pythonを再起動しないと、変更したモジュールをimportで読み込み直せないということを意味します。これを覚えておくことは大変重要です。

たとえば、まずmymain.pyをインタラクティブモードで実行したあと、**インタラクティブモードを起動したまま**で、mymod1.pyを次のように変更して保存してみましょう。

```python
x = 100
def hello():
    print("Good bye,World!")
```

そして、mymain.pyをインタラクティブモードでもう一度実行してみてください。次のように、mymod1.pyの変更が反映されていないはずです。

```python
# 出力

5
Hello,World!
```

それでは、一度インタラクティブモードを終了してください(Pythonを停止する)。それからもう一度同じmymain.pyのコードを実行してください。次のように、変更が反映されるはずです。

```python
100
Good bye,World!
```

Pythonを終了せずにモジュールの再読み込みをするには、次のように`importlib`モジュールの`reload`関数を使う方法もあります。モジュールの開発中は、一々Pythonを再起動するよりもこちらのほうが便利でしょう。一度読み込まれたmymod1モジュールを再び読み込むには、次のように記述します。

```python
import importlib
importlib.reload(mymod1)
```

## モジュールのバイトコード

import文によって読み込まれたPythonスクリプトのモジュールは、通常インタプリタによってバイトコンパイルされ__pycache__というディレクトリに保存されます。__pycache__はmainモジュールファイル(主スクリプト)が置かれていた場所に作られます。VS Code上で閲覧できるはずなので、開いてみてください。

中には、mymod1.cpython-38.pycというバイナリファイルが作られているはずです。これがmymod1.pyをバイトコンパイルして出来たバイトコードです。

通常、mainモジュールとして実行されるファイルは、実行のたびにバイトコンパイルされ、バイトコードがファイルに保存されることはありません(強制的にバイトコードを作ることは可能です)。一方、importされたファイルは(可能な限り)バイトコードを保存し、ファイル内容に変更がない限り再コンパイルしません。

このようにして、モジュールのバイトコンパイルにかける時間を節約することで、Pythonは実行までの時間を短縮する工夫をしています。通常モジュールのバイトコンパイルを意識する必要はありませんが、教養として知っておきましょう。

## 名前空間

名前空間とは、mainを始めとするモジュールの中で定義された記号(識別子)の一覧および、それらの記号が参照するオブジェクトの対応表のことです。一つのモジュールには、次の3種類の名前空間が存在します。

|名前空間|含まれる記号|
|--|--|
|ローカル名前空間|関数のなかで定義された記号|
|グローバル名前空間|モジュールファイルのトップレベル(関数の外)で定義された記号
|ビルトイン名前空間|__builtins__で定義されている記号|

それぞれの名前空間は、具体的に辞書の形で取り出すことができます。

```python
locals()
globals()
__builtins__.__dict__
```

## スコープ

**スコープ**とは、モジュールファイルのなかで、ある名前空間の記号が、**記号単体で参照できるコードの範囲**を指します。グローバル名前空間のスコープを**グローバルスコープ**、ローカル名前空間のスコープを**ローカルスコープ**、ビルトイン名前空間のスコープを**ビルトインスコープ**と呼びます。

具体例として、グローバルスコープは、モジュールのトップレベルで代入された記号を**記号単体**で使うことができるコードの範囲です。トップレベルで代入された変数や関数は、モジュールファイルのどこからでも記号単体で参照できますので、**グローバルスコープはモジュールファイル全体**ということになります。**グローバル**という言葉が紛らわしいですが、グローバル名前空間の記号はモジュールの外からは参照できません。

一方関数内で定義された記号はその関数の中でしか記号単体で参照できないので、**ローカルスコープ**は対応する関数の関数ブロックに等しくなります。

ビルトイン名前空間の記号は文字通り、どこからでも記号単体で参照できます。つまり、グローバルスコープよりもビルトインスコープのほうが広いです。

第4回「変数とメモリ」において、変数がオブジェクトに貼り付けられたラベルであるという話をしました。オブジェクトはメモリ上のある領域に格納されていることはすでに説明しました。

一方、ラベルである「変数名」の方は、あるディクショナリのキーとして保存されています。

Pythonプログラムが実行されると、Pythonは、ある特別な辞書を作成します。これは、実行中のプログラムにおける変数名をキーとし、その変数名が指すオブジェクトを値とする辞書です。この辞書のことを、**グローバル名前空間**と呼ぶことがあります。グローバルという言葉には、「グローバル名前空間に登録されている変数は、どこからでも参照できる」という意味合いが込められています。

グローバル名前空間はビルトイン関数globals()の戻り値として得られます。

```python
>>> globals()
{'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': <class '_frozen_importlib.BuiltinImporter'>, '__spec__': None, '__annotations__': {}, '__builtins__': <module 'builtins' (built-in)>}
```

この出力を見ると、すでにPythonが幾つかの変数を定義ずみであることがわかります。たとえば__name__という変数は__main__という文字列として定義されています。

```python
>>> print(__name__)
__main__
```

注)__name__変数の意味は後で説明します。

さて、グローバル名前空間は、どのような変数が定義されているかをPythonに教えるために存在しています。ためしにxという変数を定義して、実際にそれがグローバル名前空間に追加されることを確認しましょう。

```python
>>> x = 1
>>> globals()
{'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': <class '_frozen_importlib.BuiltinImporter'>, '__spec__': None, '__annotations__': {}, '__builtins__': <module 'builtins' (built-in)>, 'x': 1}
```

逆に、グローバル名前空間辞書に新たなキー：値ペアを追加することで、変数が定義されるかどうか試してみましょう。

```python
>>> globals().update({'y':2})
>>> y
2
```

このように、変数を定義するということは、グローバル名前空間に新たなキー：値ペアを追加することを意味します。

たとえばprint(x)というコードを実行すると、Pythonは、globals()名前空間を検索して、キー'x'に対応する値である整数オブジェクト1を発見し、それを印字するということをしています。このように名前空間が存在するおかげで、Pythonは、変数名とオブジェクトを対応づけることができます。

## 関数とローカル名前空間

上述したように、グローバル名前空間に登録されている変数は、どこからでも参照できます。関数の中も例外ではありません。

```python
>>> x = 5
>>> def f():
...     print(x)
...
>>> f()
5
```

ただし、関数の中で定義された変数は、グローバル名前空間には登録されず、**ローカル名前空間**という別の名前空間に登録されます。ローカル名前空間は、関数の中でlocals()関数によって出力することができます。

```python
>>> def f():
...     x = 234
...     print(locals())
... 
>>> f()
{'x': 234}
```

グローバル名前空間に登録された変数をグローバル変数、ローカル名前空間に登録された変数をローカル変数と呼びます。もう一つ、**ビルトイン**という名前空間がありますが、それについては後述します。

|定義される場所|登録される名前空間|変数の呼び名|
|---|---|---|
|関数の外|グローバル名前空間|グローバル変数|
|関数の中|ローカル名前空間|ローカル変数|
|ビルトインモジュール|ビルトイン名前空間|ビルトイン変数|

実は、ローカル名前空間は辞書に見えるだけで、本当は**辞書ではありません**。locals()関数は、ローカル名前空間を辞書のフォーマットにしたものを返すだけで、ローカル名前空間そのものを返すわけではありません。これをあまり意識する必要はありませんが、locals()の戻り値は名前空間ではないので、そこに変数を登録しても、ローカル名前空間は**変化しない**ことに注意しましょう。

```python
>>> def f():
...     x = 123
...     locals()['x'] = 567
...     print(x)
...
>>> f()
123
```

この点に関しては、[Pythonドキュメンテーション](https://docs.python.org/3/library/functions.html)のビルトイン関数の解説に、はっきりと、「locals()の戻り値を修正すべきではない」と説明があります。

なお、ローカル名前空間は、関数が呼び出されている間だけしか存続せず、関数の外からはアクセスすることができません。

```python
>>> def f():
...     x = 234
... 
>>> f()
>>> print(x)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'x' is not defined
>>> 
```

## 入れ子のローカル名前空間

関数が入れ子になっているとき、外側の関数と内側の関数に別々のローカル名前空間が存在します。

## ビルトイン名前空間

最後に、ビルトイン名前空間について説明します。ビルトイン名前空間は、ビルトイン変数やビルトイン関数が定義されている名前空間で、ここに登録されている変数や関数は、やはりプログラムのどこからでも参照できるようになっています。

ビルトイン名前空間に登録されている変数をリストの形式で表示するには、次のコードを実行します。

```python
>>> dir(__builtins__)
['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning', 'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError', 'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning', 'EOFError', 'Ellipsis',  

(...中略...)

'int', 'isinstance', 'issubclass', 'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview', 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property', 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars', 'zip']
>>> len(dir(__builtins__))
155
```

上記のように、155のビルトイン変数/関数が定義されていることが分かります。ビルトイン名前空間は、変数/関数を参照するためだけに存在している名前空間ですから、ビルトイン名前空間に新たな変数を登録することは通常行いませんし、必要もありません。

関数の外（トップレベル）で代入操作を行うと、グローバル名前空間に変数が登録されるのであって、ビルトイン名前空間に変数名が登録されることはありません。

## 名前解決

さて、たとえば、

```python
print(x)
```

というコードがあったとき、Pythonのインタープリタは、xという変数名がどのオブジェクトを指しているのか特定しなくてはなりません。この作業を**名前解決**と呼びます。Pythonでの名前解決は次の順番に名前空間を探索することにより行われます。

1. ローカル名前空間(Local)
2. 外側の関数の名前空間(Enclosing)
3. グローバル名前空間(Global)
4. ビルトイン名前空間(Built-in)

このルールを**LEGBルール**と呼びます。

グローバル名前空間とローカル名前空間に同じ名前の変数が存在する場合、ローカル名前空間が優先されます。

```python
>>> x = 123
>>> def f():
...     x = 456
...     print(x)
...
>>> f()
456
```

関数の中においては、グローバル変数を参照できますが、グローバル変数への代入はできません。どうしても代入をしたい場合は、関数の最初に、global宣言子を使って、変数がグローバル変数であることを宣言します。

```python
>>> x = 123
>>> def f():
...     global x
...     x = 456
...
>>> f()
>>> print(x)
456
```

## モジュールの作成とインポート

**モジュール**という言葉には難しい意味合いはなく、「実行可能なPythonのファイル」とほとんど同じ意味です。とくに、別のPythonプログラムからインポートされる想定で作られたPythonファイルをモジュールと言うことが多いようです。それではまず、my_moduleという名前の空のモジュールを作ってみましょう。my_module.pyという名前のファイルを作って次の内容を保存しておきましょう。

```python
# my_moduleの中身
x = 123
```

次にこれを読み込みます。

```python
>>> import my_module
>>> print(my_module.x)
123
```

このように、モジュールを読み込むと、モジュール内で
