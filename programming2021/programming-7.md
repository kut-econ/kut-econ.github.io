# 第7回 標準ライブラリ(2)

- [第7回 標準ライブラリ(2)](#第7回-標準ライブラリ2)
  - [辞書(dict)](#辞書dict)
  - [ループでの挙動](#ループでの挙動)
  - [ハッシュ可能オブジェクト](#ハッシュ可能オブジェクト)
  - [ハッシュ表](#ハッシュ表)
  - [集合](#集合)
  - [課題](#課題)

## 辞書(dict)

辞書(ディクショナリとも呼びます)型はRのリストに似たデータ構造で、次の特徴を持ちます。

- イテラブル
- ミュータブル
- 「キーオブジェクト」と「値オブジェクト」のペアを保存する
- ハッシュ可能オブジェクトだけをキーに持てる
- 任意のオブジェクトを値に持てる
- キーを指定して値にアクセスする
- インデックス参照やスライス記法は受け付けない

辞書はPythonにおいて重要であるだけでなく、**ハッシュテーブル**という計算機科学において非常に重要なデータ構造なので、詳しく説明します。

リストは、要素を列挙したものでした。リストは本質的に**順序集合**です。

```python
>>> x = ['foo','bar','baz']
>>> print(x[1])
bar
```

一方、辞書は要素の順序集合ではなく、オブジェクトのペアの集合です。ペアを構成するオブジェクトは、**キー**および**値**と呼ばれます。

辞書を説明するには、実際の辞書の例が分かりやすいです。

|英単語|意味|
|--|--|
|yep|はい|
|yes|はい|
|yet|しかし|

といった(あまり役に立たない)英和辞書があったとします。この辞書では、英単語から意味を検索できるが、その逆(意味から英単語を検索)はできないとします。

英単語がキー、意味が値に相当します。キーは一意でなくてはなりませんが、値は重複があっても構いません。

実際にこの辞書を作るには次のようにします。

```python
>>> x = {'yep':'はい','yes':'はい','yet':'しかし'}
>>> x
{'yep': 'はい', 'yes': 'はい', 'yet': 'しかし'}
```

ちょうどリストにおいてインデックスから要素を取得したように、キーを指定すれば値を取得できます。

```python
>>> x['yep']
'はい'
>>> x['yet']
'しかし'
```

キーの一覧、値の一覧、キーと値のペアの一覧を取得するには、keysメソッド、valuesメソッド、itemsメソッドを使います。

```python
>>> x.keys()
dict_keys(['yep', 'yes', 'yet'])
>>> x.values()
dict_values(['はい', 'はい', 'しかし'])
>>> x.items()
dict_items([('yep', 'はい'), ('yes', 'はい'), ('yet', 'しかし')])
```

上記のようにキーの一覧、値の一覧、ペアの一覧はdict_keys、dict_values、dict_itemsという特殊な**イテラブル**データ型で返されます。これは、適宜リストや集合、タプルに変換して用いることができます。

たとえばリストに変換するには、関数listを使います。

```python
>>> y = list(x.keys())
>>> y
['yep', 'yes', 'yet']
>>> z = list(x.values())
>>> z
['はい', 'はい', 'しかし']
>>> a = list(x.items())
>>> a
[('yep', 'はい'), ('yes', 'はい'), ('yet', 'しかし')]
```

## ループでの挙動

辞書をリストの代わりにループインデックスの範囲として指定すると、ループインデックスにはキーだけが代入されます。つまり、次の2つのコードは全く同じ意味です。

```python
# %%
# xは辞書
for i in x.keys():
    print(i)
# %%
for i in x:
    print(i)
```

キーと値の両方を使いたいときは、次のようにしなくてはなりません。

```python
# %%
x = {'yep':'はい','yes':'はい','yet':'しかし'}
for i in x.items():
    print(i)
```

このように書くと、ループインデックスにはループごとにキーと値のタプルが代入されます。

```python
# 出力
('yep', 'はい')
('yes', 'はい')
('yet', 'しかし')
```

このようループインデックスにタプルを返すイテラブルの場合、次のようなループインデックスへの**アンパック代入**がサポートされています。

```python
# %%
x = {'yep':'はい','yes':'はい','yet':'しかし'}
for i,j in x.items():
    print(i + ' --> ' + j)
```

```python
# 出力

yep --> はい
yes --> はい
yet --> しかし
```

## ハッシュ可能オブジェクト

任意のオブジェクトが値になれますが、キーに指定できるのは、**ハッシュ可能な**Pythonオブジェクトのみです。

あるアルゴリズムによってオブジェクトを数字に変換することをハッシュ化と呼びます。ハッシュ化によって得られる数値をハッシュ値と呼び、当のアルゴリズムをハッシュ関数と呼びます。全てのPythonオブジェクトがハッシュ化できるわけではなく、ハッシュ化できるオブジェクトをハッシュ可能(hashable)であると言います。

リストや集合といったミュータブルなビルトインオブジェクトはハッシュ可能ではありません。数値や文字列などイミュータブルなビルトインオブジェクトはほとんど全てハッシュ可能ですが、例外はあります。

```python
>>> x = {}
>>> x[(1,2,3)]=123
```

```python
>>> x = {}
>>> x[(1,2,[3])]=123
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unhashable type: 'list'
```

一つ目の例ではタプルをキーに指定していますが、全く問題ありません。一方二つ目の例でもタプルをキーにしていますが、このタプルは[3]というハッシュ不可能な要素(リスト)を持っているため、ハッシュ可能ではありません。タプルがハッシュ可能であるためには、そのすべての要素がハッシュ可能である必要があります。

## ハッシュ表

それでは、次のコードを例に、辞書を作成する際に何が起きているのかを見ていきましょう。

```python
>>> x = {'foo':123,'bar':456,'baz':789}
```

上のコードを実行すると、Pythonは232バイトのメモリ領域を確保します（具体的なバイト数は処理系やPythonのヴァージョンに依存します）。

```python
>>> import sys
>>> sys.getsizeof(x)
232
```

この232バイトのうち、104バイトは参照カウンタなどを含むオーバーヘッドで、本質的なのは残り128バイトです。この128バイトは、**ハッシュ表(ハッシュテーブル)**というデータ構造を格納しています。ハッシュ表の役割は、キーオブジェクトを、要素オブジェクト（キーに対して**値**ともいいます）に対応付けることです。

最近のバージョンのPythonでは、ハッシュ表はインデックス表とエントリー表という二つの部分から構成されています(本講義では仮にそのように呼ぶことにします)。インデックス表は、1区画1バイトからなる8区画の一続きのメモリ領域で、合計8バイトを占有しています。一方エントリー表は、1区画24バイトからなる5区画の一続きのメモリ領域で、合計120バイトを占有しています。

次に、Pythonは第一のキーオブジェクト'foo'をハッシュ化します。

```python
>>> hash("foo")
531872228806607122
>>> hash("foo") & 0b111
2
```

上のコードでは、hash関数で'foo'をハッシュ化し、下3ビットを取り出しています。Pythonは、キーオブジェクト'foo'（のアドレス）、値オブジェクト123（のアドレス）、そしてキーのハッシュ値（上記の値）をセットにしてエントリー表の第0番目に記録します。キー・値・ハッシュ値がそれぞれ8バイトずつ占有するので、合計8×3=24バイトで1区画を占有します。

次に、ハッシュ値の下3桁をみると、0b010=2ですので、Pythonは、インデックス表の2番目の区画に、0を記録します。これにより、キー'foo'に対応する情報は、エントリー表の0番目の区画に記録されているということが分かるようになります。同じことを、'bar'と'baz'に対しても行うと、図のようなインデックス表とエントリー表ができあがります(ハッシュ化により'bar'は0b110=6、'baz'は0b001=1を割り当てられる）。

```python
>>> hash("bar")
-1001163682187755818
>>> hash("bar") & 0b111
6
>>> hash("baz")
2724165034148455057
>>> hash("baz") & 0b111
1
```

さて、次のようなコードを実行したとしましょう。

```python
# xは定義済み
>>> print(x['baz'])
789
```

このとき、Pythonは、まずキーオブジェクト'baz'をハッシュ化して、その2進数表記の下3桁をとりだします。すると0b001=1という値でしたので、インデックステーブルの1番目の要素を探します。すると、2という値が記録してあるので、エントリーテーブルの2番目の要素をチェックし、そこに'baz'と789が登録されていることを確認します。このようにして、値789を取り出し、print関数で印字しているということになります。

なお、ハッシュ化して下3桁をとると、複数のキーが同じインデックスになってしまうことがあります。これを**ハッシュ衝突**と呼びます。二つのキーでハッシュ衝突が起きると、後からやってきたキーは適当なアルゴリズムで別のインデックスを振られます（このアルゴリズムに興味がある人は、自分で調べてみましょう）。

インデックス表が埋まってくると、だんだんと衝突の確率が上がってきます。衝突が多いほど、登録にも検索にも時間がかかるようになります。ですので、衝突を最小限に抑えるために、インデックス表の区画数はエントリー表よりもすこし大きめに確保してあります。エントリー表が満杯になると、インデックス表とエントリー表が両方とも拡張されます。このとき、エントリー表のサイズは10区画、インデックス表のサイズは16区画に拡張されます。再びエントリー表が一杯になると、再度拡張がおき、今度はエントリー表は21区画、インデックス表は32区画になります。このようにして、エントリー表が一杯になるたびに、おおよそ倍々にインデックス表とエントリー表は拡張されていきます。エントリー表のサイズは、おおよそインデックス表の2/3になるように計算されています。

理論的には、辞書の要素が増えるにつれ、オーバヘッドを除く占有バイト数は次のように変化していきます。

|要素数|エントリー表のバイト数|インデックス表のバイト数|占有バイト数|
|-|-|-|-|
|1~5|24x5=120|1x8=8|128|
|6~10|24x10=240|1x16=16|256|
|11~21|24x21=504|1x32=32|536|
|22~42|24x42=1008|1x64=64|1072|
|43~85|24x85=2040|1x128=128|2168|
|86~170|24x170=4080|2x256=512|4592|
|171~341|24x341=8184|2x512=1024|9208|

以下は、本当に上記のようなことが起きているかを確かめるためのコードです。

```python
import sys
x = dict()
prev_size = 0
curr_size = 0
overhead = sys.getsizeof(x)-128
for i in range(1,2**6+1):
    x.update({i:i})
    curr_size = sys.getsizeof(x)
    if curr_size != prev_size:
        print(i,sys.getsizeof(x)-overhead)
    prev_size = curr_size
```

```python
# 出力
1 128
6 256
11 536
22 1072
43 2168
86 4592
171 9208
342 18416
```

1列目は辞書に加えた要素の数、2列目はオーバーヘッドを除いたメモリの占有バイト数です。

辞書の仕組みが何となく分かっていただけたでしょうか？いずれにせよ、重要なのは、

- 辞書は値オブジェクト（つまり要素）へのアドレスを配列で格納している
- ハッシュ表がキーオブジェクトを配列のインデックスに変換する

ということです。辞書オブジェクトがリストと同じく要素のアドレスしか記憶していないことを把握しておかないと、リストと同じ類のミスを誘発しがちであることに注意しましょう。

## 集合

集合型は、内部構造をもたないオブジェクトの集まりです。集合は、値のないキーだけの辞書と思ってほぼ間違いはありません。以下のような特徴を持ちます。

- イテラブル
- ミュータブル
- インデックス・スライス参照不可
- キー参照不可
- ハッシュ可能オブジェクトだけを要素に持てる
- 算術演算不可

集合の要素は辞書のキーに相当するため、ハッシュ可能でないといけません。

```python
>>> x = {[3],5}
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unhashable type: 'list'
```

## 課題

1. 上述の表にあるように、辞書の要素数が86以上のとき、インデックス表の1区画あたりのバイト数は1バイトから2バイトに増量されます。この理由を考えて答えなさい（自分で推測しても良いし、インターネットで検索しても良い）。
