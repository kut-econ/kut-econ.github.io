# 第5回 データ型と制御構文

- [第5回 データ型と制御構文](#第5回-データ型と制御構文)
  - [リストのしくみ](#リストのしくみ)
  - [リスト要素の修正](#リスト要素の修正)

## リストのしくみ

この謎を解き明かすには、急がばまわれ、Pythonのデータ型をじっくり観察してみるのがよろしいです。まずはリストを見ていきましょう。

次のように長さ5のリストを作成してxに代入すると何が起きるか考えてみましょう。

```python
x = [120,-3,'Py','thon','foo']
```

上記を実行すると、Pythonは、リストオブジェクトを保存するための104バイトのメモリ領域を確保して、それにxという名前をつけます。この104バイトのメモリ領域がリストオブジェクトの正体です。

104バイトのうち64バイトには、参照カウンタやら何やらが保存されていますが、あまり重要ではありません。重要なのは残り40バイトの**配列**と呼ばれる部分です。

![list structure](img/list_structure.drawio.png)

この合計40バイトの配列はメモリ上で一続きになっており、各8バイトの5つの区画に分かれています。それぞれの区画には、リストの要素になっているオブジェクトのアドレスが格納されています。

たとえば第1要素である120という整数オブジェクトは、メモリ上の9604番地に存在します（実際にはアドレスはもっと大きな整数ですが、面倒なので下4桁だけ使っています）が、それに対応して、リストオブジェクトの配列の第1番目の区画には、オブジェクト120のアドレスである9604が書き込んであります。他の要素についても同じで、配列の第k番目の区画には、リストの第k番目の要素であるオブジェクトのアドレスが格納されています。

このように、リストオブジェクトは、その要素そのものを覚えているのではなく、要素オブジェクトのアドレスを覚えています。このおかげで、リストオブジェクトには、整数だろうが、小数だろうが、文字列だろうが、はたまたリストであろうが、どんなPythonオブジェクトでも、好きな順番で詰め込めるようになっています。なぜなら、どんなオブジェクトでも、アドレスの形式は同じだからです。

たとえば

```python
>>> x = [120,-3,'Py','thon','foo']
>>> x[1]
-3
>>> 
```

のように入力するときPythonは、xというリストオブジェクトの中にある配列領域の2番目の要素に書いてあるアドレスをチェックして、次にそのアドレスに行ってどんなオブジェクトがあるのかチェックします。するとそこには-3という整数オブジェクトがあったので、それを出力してくれているわけです。

## リスト要素の修正

では次に、リストの要素の書き換えについて考えてみます。たとえば第3要素を'Py'から'bar'に書き換えたいとします。この場合、次のように書きます。

```python
x[2] = 'bar'
```

するとPythonは何をするかというと、'bar'という文字列オブジェクトをメモリ上に作成して、そのアドレス0800をリストxの配列の第3要素に上書きで格納します。これによって、オブジェクト'Py'はリストxからは忘れ去られ、代わりに'bar'がリストのメンバーとして参入します。

![list change element](img/list_change_element.drawio.png)

ここで重要なのは、もともと'Py'が存在していた5782番地の内容が書き換えられるわけではないということです。そうではなく、単にリストxが覚えているアドレスが付け替えられるだけです。
