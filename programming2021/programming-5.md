# 第5回 データ型と制御構文

- [第5回 データ型と制御構文](#第5回-データ型と制御構文)
  - [ミュータブルとイミュータブル](#ミュータブルとイミュータブル)
  - [リストのしくみ](#リストのしくみ)
  - [リスト要素の修正](#リスト要素の修正)

## ミュータブルとイミュータブル

Pythonには、初学者を混乱させる**ミュータブル**なオブジェクトと**イミュータブル**なオブジェクトという概念があります。ミュータブルなオブジェクトは書き換え可能なオブジェクトであり、イミュータブルなオブジェクトとは、書き換え不可能なオブジェクトです。

| 分類            | データ型           |
| -------------- | ------------------ |
| ミュータブル   | リスト(list)、辞書(dict)、集合(set) |
| イミュータブル | 整数(int)、浮動小数点数(float)、文字列(str)、ブール値(bool)、タプル(tuple)|

ミュータブルとイミュータブルが紛らわしい概念であるのは、それが**変数**と**定数**の概念に、一見似ているからです。

**定数**という概念はC言語などに現れる概念で、**値の変更を禁止された変数**のことです。C言語では、次のようにして定数aを宣言します。

```C
const int a=5;
```

このように書くと、aは定数を表し、代入を受け付けなくなります。

```C
a = 6; //これはコンパイルエラーになる
```

```C
test.c: In function ‘main’:
test.c:7:4: error: assignment of read-only variable ‘a’
   a=6;
```

Pythonには定数の概念は存在しません。どの変数も、いつでも好きなオブジェクトに貼り付けられる**ラベル**です(箱ではありません)。箱ではなくラベルですから、イミュータブルなオブジェクトからイミュータブルなオブジェクトに付け替えられますし、イミュータブルなオブジェクトからミュータブルなオブジェクトに付け替えることも可能です。

実際、文字列はイミュータブルですが、次のコードは全く正常であり、何のエラーも起きません。

```python
x = "First"
x = "Second"
x = "Third"
```

一方、イミュータブルやミュータブルは、ラベルが参照しているオブジェクトの性質であり、定数や変数とは異なる概念です。文字列はイミュータブルなので、その内容を変更することはできません。

```python
x = "Immutable"
x[0] = "i" #エラーが起きる
```

上記2行目は、"Immutable"という文字列オブジェクトの最初の要素"I"を"i"に入れ替えよ、という許されない命令です。したがってエラーが出ます。

```python
Traceback (most recent call last):
  File "test.py", line 2, in <module>
    x[0] = "i"
TypeError: 'str' object does not support item assignment
```

よくある初学者のミスは、次のように、文字列の一部をスライスで変更しようというものです。

```python
>>> x = "This is Python."
>>> x[0:4] = "It"
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'str' object does not support item assignment
```

しかし同じことをリストで行うのは、全く正しい操作です。

```python
>>> x = [1,2,3,4,5,6]
>>> x[0:4] = [1,2]
>>> x
[1, 2, 5, 6]
>>>
```

初学者からしてみれば、全く不可解と言わざるを得ません。(全く、プログラミング初心者をわざと混乱させようとしているとしか思えませんね。)なぜこんなことになっちゃったのでしょうか。

## リストのしくみ

この謎を解き明かすには、急がばまわれ、Pythonのデータ型をじっくり観察してみるのがよろしいです。まずはリストを見ていきましょう。

次のように長さ5のリストを作成してxに代入すると何が起きるか考えてみましょう。

```python
x = [120,-3,'Py','thon','foo']
```

上記を実行すると、Pythonは、リストオブジェクトを保存するための104バイトのメモリ領域を確保して、それにxという名前をつけます。この104バイトのメモリ領域がリストオブジェクトの正体です。

104バイトのうち64バイトには、参照カウンタやら何やらが保存されていますが、あまり重要ではありません。重要なのは残り40バイトの**配列**と呼ばれる部分です。

![list structure](img/list_structure.drawio.png)

この合計40バイトの配列はメモリ上で一続きになっており、各8バイトの5つの区画に分かれています。それぞれの区画には、リストの要素になっているオブジェクトのアドレスが格納されています。

たとえば第1要素である120という整数オブジェクトは、メモリ上の9604番地に存在します（実際にはアドレスはもっと大きな整数ですが、面倒なので下4桁だけ使っています）が、それに対応して、リストオブジェクトの配列の第1番目の区画には、オブジェクト120のアドレスである9604が書き込んであります。他の要素についても同じで、配列の第$k$番目の区画には、リストの第$k$番目の要素であるオブジェクトのアドレスが格納されています。

このように、リストオブジェクトは、その要素そのものを覚えているのではなく、要素オブジェクトのアドレスを覚えています。このおかげで、リストオブジェクトには、整数だろうが、小数だろうが、文字列だろうが、はたまたリストであろうが、どんなPythonオブジェクトでも、好きな順番で詰め込めるようになっています。なぜなら、どんなオブジェクトでも、アドレスの形式は同じだからです。

たとえば

```python
>>> x = [120,-3,'Py','thon','foo']
>>> x[1]
-3
>>> 
```

のように入力するときPythonは、xというリストオブジェクトの中にある配列領域の2番目の要素に書いてあるアドレスをチェックして、次にそのアドレスに行ってどんなオブジェクトがあるのかチェックします。するとそこには-3という整数オブジェクトがあったので、それを出力してくれているわけです。

## リスト要素の修正

では次に、リストの要素の書き換えについて考えてみます。たとえば第3要素を'Py'から'bar'に書き換えたいとします。この場合、次のように書きます。

```python
x[2] = 'bar'
```

するとPythonは何をするかというと、'bar'という文字列オブジェクトをメモリ上に作成して、そのアドレス0800をリストxの配列の第3要素に上書きで格納します。これによって、オブジェクト'Py'はリストxからは忘れ去られ、代わりに'bar'がリストのメンバーとして参入します。

![list change element](img/list_change_element.drawio.png)

ここで重要なのは、もともと-3が存在していた7636番地の内容が書き換えられるわけではないということです。そうではなく、単にリストxが覚えているアドレスが付け替えられるだけです。
