# 第1回 プログラミング概論

- [第1回 プログラミング概論](#第1回-プログラミング概論)
  - [授業で使う言語](#授業で使う言語)
  - [なんでいまさらPython？](#なんでいまさらpython)
  - [深ぼりして何がうれしい？](#深ぼりして何がうれしい)
  - [学習教材](#学習教材)
  - [REPLによる対話的実行](#replによる対話的実行)
    - [練習1](#練習1)
  - [コマンドラインによる実行](#コマンドラインによる実行)
    - [練習2](#練習2)
  - [本講義前半の具体的な目標](#本講義前半の具体的な目標)
  - [2進数と16進数](#2進数と16進数)
  - [コンピューターの仕組み](#コンピューターの仕組み)
  - [メモリの仕組み](#メモリの仕組み)
  - [CPUの働き](#cpuの働き)
  - [マシン語](#マシン語)
  - [プログラミング言語の種類](#プログラミング言語の種類)
    - [コンパイル型言語](#コンパイル型言語)
    - [インタープリタ型言語](#インタープリタ型言語)
    - [アセンブリ言語](#アセンブリ言語)
  - [抽象度](#抽象度)
  - [プログラミング上達のコツ](#プログラミング上達のコツ)
    - [正しいタイピング](#正しいタイピング)
    - [キーバインドをマスターしよう](#キーバインドをマスターしよう)
  - [まとめ](#まとめ)
  - [参考書](#参考書)
  - [宿題（ホームワーク）](#宿題ホームワーク)
  - [課題（アサインメント）](#課題アサインメント)

## 授業で使う言語

この授業は、プログラミングの授業です。
プログラミングの授業であるからには、少なくとも１つのプログラミング言語を扱わねばなりません。
この授業では、主にPythonを扱っていくことにします。それから、Rも少し扱っていきますが、Rについては、皆さんは統計学2や計量経済学（どちらも2年生科目)の授業で学んで来ているでしょうから、その基礎は押さえていると仮定し、いちいち復習はしません。たとえば、Rのベクトルやデータフレームがどういったものだったか忘れてしまっている人がいたら、復習しておいてください。それから、if条件分岐やforループについて、構文を忘れてしまっている人は、思い出しておくと良いでしょう。

さて、Pythonについては多くの方が名前くらい聞いたことがあるでしょう。触ったことがある人もおられることでしょう。以前はPythonの国内人気はいまいちでしたが、ここ10年ほどで機械学習ブームの波にのって人気が高まり、いまでは世界で最もポピュラーなプログラミング言語となりました。従って、YouTubeなどに、初心者向けのPythonのわかりやすい解説動画がたくさんあり、また独学に適した日本語の参考書も次々と発売されています（本講義で教科書として用いる『独習Python』もまたそうした書籍の一つであり、2020年に発売されたばかりです）。

## なんでいまさらPython？

独学のための良質の素材があふれているのであれば、なぜ本講義でわざわざプログラミング、そしてPythonを学ばなければならないのでしょうか。以下に、ちまたの教材に任せきってしまうことの問題を挙げてみましょう。

- 独学では、モチベーションが沸かない。
- 研究での活用がわかりにくい。
- 表面的な説明がおおく、Pythonの深いところがなかなか見えてこない。
- 高度な内容をどうやって勉強したらいいのかわからない。

こういったところでしょうか。要するに、とりあえずPythonを動かすことは独学で簡単にできるようになるのですが、そこから先（深ぼりしたり、応用したり）が見えないのです。先が見えないものは勉強したくないでしょう。

## 深ぼりして何がうれしい？

では、なぜPythonを深ぼりする必要があるのでしょうか？それは、Pythonが、深ぼりしないと間違いを冒すタイプの言語だからです。言い換えると、プログラムというものがどのように情報を扱っているのかをある程度理解しないと、Pythonを正しく使うことは難しいと言えます。その意味では、実はPythonは初学者向けの言語ではないと筆者は考えています。

これは見方を変えると、Pythonを正しく理解すれば、その過程でプログラミングへの理解がずっと深まるということです。この点で、PythonはRとかなり違います。Rは、プログラミングにそれほど精通していなくても使いやすく設計されています。Rに慣れた学生の皆さんは、Pythonを深く学ぶことで、プログラミングというものが何なのか、より深い実感をもつことができるようになるでしょう。

## 学習教材

皆さんが本講義を通してPythonを学ぶに当たっては、以下の教材を有効活用することをおすすめします。

1. [Python公式ドキュメント](https://docs.python.org/ja/3/)
2. [『独習Python』(教科書)](https://www.amazon.co.jp/%E7%8B%AC%E7%BF%92Python-%E5%B1%B1%E7%94%B0-%E7%A5%A5%E5%AF%9B/dp/4798163643/ref=tmm_pap_swatch_0?_encoding=UTF8&qid=1621478622&sr=8-1)
3. 本サイト

内容の詳細さで言うと、`1>2>3`です。本サイトではPythonの標準機能の一部しか紹介できませんので、足りない部分を2の教科書で補うことにします。さらに、プログラミングをしていると、教科書を含む一般向け書籍にはなかなか書かれていないようなことも時々調べなくてはなりません。そのような場合には、最終的には1のPython公式ドキュメントを当たらねばなりません。さらに、公式ドキュメントにも載っていないことは高度な専門書や、ネット上の非公式なドキュメントを参考にしたり、[Stack Over Flow](https://stackoverflow.com/)のようなサイトで検索・投書するか、自分で試行錯誤しなくてはなりません。

また、本講義はPythonの標準機能を説明するだけのものではありませんので上の教材だけでは不十分です。標準機能以外に関する補助的教材や参考資料については、適宜紹介することにします。

## REPLによる対話的実行

それでは前置きが長くなりすぎたので、そろそろPythonを動かしてみましょう。Pythonを動かすには、様々な方法がありますが、まずはREPL(Read-Eval-Print Loop)を用いた対話的実行を行ってみましょう。

ウィンドウズを起動して、画面の左下の検索ウィンドウにAnacondaと打ち込んで、Anaconda Promptを起動しましょう（Anaconda Powershell Promptでも構いません）。Anacondaを起動したら、pythonと入力し、pythonの対話的インタープリタREPLを起動しましょう。プロンプトと呼ばれる'>>>'記号が現れて、入力待ちの状態になるはずです。

REPLは、Pythonのコードを1行ごとに評価し、即時にその結果を表示してくれるシステムです。小さなコード断片の挙動を確かめる際などに便利です。

Pythonには、整数や計算式などはそれ自体がPythonのコードと見なされるという特徴があります。そのおかげで、PythonのREPLを計算機として用いることができます。たとえば、何でも良いので、簡単な足し算や引き算をREPLに入力してみましょう。（入力の最後にはEnterキーを押します。）

```python
>>> 1 + 1
2
>>> 10 - 5
5
>>> 3 * 2
6
>>> 8 / 2
4.0
>>> 11 // 3
3
>>> 11 % 3
2
>>> 5 ** 3
125
```

このように、REPLは簡単な計算機として用いることができます。なお、Pythonにおける2項算術演算子は以下の通りです。

| 演算子 | 機能                       |
| ------ | -------------------------- |
| +      | 可算                       |
| -      | 減算                       |
| *      | 乗算                       |
| **     | べき乗                     |
| /      | 除算                       |
| //     | 整数除算（余りを切り捨て） |
| %      | 剰余                       |

上記の表は教科書のセクション3.1にもありますので確認しておいてください。

なお3つ以上の数の演算を行うには、演算子の優先順位に気を付けなければならないのはRと同じです。たとえば

```python
>>> 2 + 3 * 5
17
```

のように掛け算は足し算よりも先に評価されます。演算子の評価順序を明確にしたいときは、丸カッコを使います。

```python
>>> (2 + 3) * 5
25
```

演算子の優先順位については教科書のセクション3.6(pp. 107)に解説がありますので、読んでおいてください。ただし、計算式においては、演算子の評価順序には過剰に頼り過ぎず、丸カッコを積極的に使うことをお勧めします。でないと、あとからコードを見返したときに、非常に理解しにくくなってしまうからです。

### 練習1

次の計算をPythonで実行したらどのような結果が得られるかを予測しなさい。

```python
# Q1
>>>(5 % 3) ** (7 // 2)
```

```python
# Q2
>>>(5.5 - 2.5 + 3.0) * 2.0
```

上記Q1, Q2の予測をREPLで確かめられたら、同じように様々な計算を自分で考えてREPLで実行し、予測と一致するか確かめなさい。

----

それでは、次にもう少し高度なことをしてみます。以下のように入力して、変数xに整数1を代入し、xの値を表示してみましょう。

```python
>>> x = 1
>>> x
1
```

このように、'='記号を使うと左辺の変数に右辺の値を代入できます。(Rでは、同様の操作に'<-'という矢印演算子を用いましたね。)

それでは、さらに変数を用いて色々な演算をしてみましょう。

```python
>>> x = 1
>>> y = 2
>>> x + y + 3
6
>>> z = y + 1
>>> x - z
-2
>>> x = z ** y
>>> x
9
>>> x = x - 1
>>> x
8
```

このように、変数は演算の中で用いることができます。これについてはRでもほとんど同じなので、細かい説明は不要でしょう。

最後に"Hello, World!"を出力しておきましょう。これについても、Rと全く同じですので、説明が要らないくらいです。(実際、Rのコードと見分けがつきません。)

```python
>>> print("Hello, World!")
Hello, World!
```

Rと同じように、ダブルクォーテーションでくくられた部分は、Pythonにより文字列と解釈されます。printは、引数に与えられた文字列や数を画面に出力するだけの関数です。

REPLを終了してAnaconda promptに戻るときは、次のように入力します。

```python
>>>exit()
```

## コマンドラインによる実行

それでは次に、Pythonのコードをファイルに保存してコマンドラインから実行する方法を試してみましょう。Anaconda promptで次のように入力してhello.pyというテキストファイルを作成します。

```anaconda
(base) C:\Users\hogehoge>notepad hello.py
```

"hello.pyは存在しません。新しく作成しますか？"と聞かれたら「はい」を選択するとメモ帳が起動します。メモ帳で、ファイルの先頭行に次のような1行を記述してください。

```python
print("Hello, World!")
```

次にファイルを保存して閉じ、Anaconda promptで次のように入力すると、ファイルに記述したPythonコードを実行することができます。

```anaconda
(base) C:\Users\hogehoge>python hello.py
Hello, World!

```

なお、Pythonコードを記述するファイル（スクリプトと呼ぶ）の名前には拡張子.pyを付けるのが普通です。

それではもう一度同じファイルを開いて、もう少し中身を豪華にしてみましょう。

```python
print("Hello, World!")
x = 1
y = 2
z = x + y
print(x)
print(y)
print(z)
```

これを実行すると、以下のようになります。

```anaconda
(base) C:\Users\Kobayashi>python hello.py
Hello, World!
1
2
3

```

このように、Pythonでは、**文**を改行で区切って並べることにより、上から順番に文が実行されていきます。文については教科書のセクション1.5.2に詳しい説明があるので良く読んでおいてください。

### 練習2

5の5乗を計算して画面に出力するpower5_5.pyというファイルを作成し、実行しなさい。

## 本講義前半の具体的な目標

遅くなりましたが、このあたりで、本講義前半部分(第1～7回)の目標を延べておきます。Pythonは非常に多機能ですので、それらの機能を全て講義の中で解説するのは不可能ですし、またその必要もありません。したがって、本講義では、Pythonのエッセンスをマスターするために、具体的な目標を掲げたいと思います。以下のPython文をみてください。

```python
>>> x = 123
```

本講義の前半部分（第7回目まで)では、**この一行のPython文において何が起こっているのかを理解すること**を目標にしたいと思います。

記の代入文はもっとも基本的なPythonの文ですから、これを理解せずにPythonプログラマになるのも難しいように思います。もちろん理解していなくても、どんどんPythonを使ってみるべきです。むしろ、上の代入文で何が起きているのかを大体でも良いので説明できるようになるまでには、かなりの量のプログラミングを行い、実験を重ねなければならないのではないかと思います。残念ながら本講義だけでは、上の代入文を完全に説明しきることはできません。それでも、そこらへんの入門書を2~3冊読み終えた人と同程度には、理解できるようになることを目指したいと思います。

さて、上記の代入文が入力されるとき、一体何が起きているのかを理解するためには、まず、プログラムといったものがどのように動いているのかといったことの説明から始めなくてはなりません。以下、多少難しい座学になりますがお付き合いください。

## 2進数と16進数

2進数や16進数については、多くの方が高校や大学で学んだことがあることでしょう。しかしながら、以降の説明で非常に重要ですので、ここでこれらの概念を簡単に復習しましょう。

ご存じの通り、私たちが普段使っている10で桁上がりする数字は、10進数と呼ばれます。一方、2で桁上がりする数を2進数、16で桁上がりする数を16進数と呼び、情報科学では10進数と並んで良く用いられる数の表し方です。

2進数では、2で桁上がりするため、10進数における2～9の数字は現れません。また、16進数では、10進数における0~9だけでは1桁を表すのに足りないため、a~fのアルファベットを用います。具体的には、3つの数表記には、以下のような関係があります。

| 10進数 | 2進数 | 16進数 |
| -----: | ----: | -----: |
|      0 |     0 |      0 |
|      1 |     1 |      1 |
|      2 |    10 |      2 |
|      3 |    11 |      3 |
|      4 |   100 |      4 |
|      5 |   101 |      5 |
|      6 |   110 |      6 |
|      7 |   111 |      7 |
|      8 |  1000 |      8 |
|      9 |  1001 |      9 |
|     10 |  1010 |      a |
|     11 |  1011 |      b |
|     12 |  1100 |      c |
|     13 |  1101 |      d |
|     14 |  1110 |      e |
|     15 |  1111 |      f |
|     16 | 10000 |     10 |

ある数が2進数で表記されていることを明確にするため、2進数の先頭に0bという接頭辞を付けることがあります(bはbinaryより)。同様に16進数には接頭辞0xをつけます(xはhexadecimalより)。たとえば、0x1eは0b11110すなわち10進数での30を表します（分かりましたか？）。

10進数、2進数、16進数の間の変換に慣れておきましょう。とくに2進数と16進数の間の変換は重要です。これは全く難しくありません。インターネットなどにいくらでも情報がありますので、練習しておきましょう。

10進数、2進数、16進数の間の変換は、Pythonを用いても行うことができます。次のPythonコードは、それぞれ、10進数の123を2進数、16進数に変換するものです。

```python
>>> bin(123)
'0b1111011'
>>> hex(123)
'0x7b'
```

このように関数binとhexを使えば10進数をそれぞれ2進数、16進数に変換することができます。

また、逆の変換をするときは、次のように数字を入力するだけです。

```python
>>> 0b1111011
123
>>> 0x7b
123
```

## コンピューターの仕組み

パソコンは、様々な部品から構成されていますが、プログラミングの初心者がまず知っておかなければならないのが、CPUとメインメモリの働きです。メインメモリはランダムアクセスメモリ(Random Access Memory)とも呼ばれるので、RAMと表記されることもあります。

CPUとメモリ(メインメモリ)は、記憶装置です。パソコンにはいくつもの記憶装置が内臓されていますが、どの記憶装置も、文字や整数や小数だけでなく、プログラムなど、すべての情報を0と1の配列に変換して記憶しています。

CPUとメモリはどちらもトランジスタで構成された集積回路(IC, Integrated Circuit)ですが、次のような性質の違いがあります。

|          | CPU          | メモリ |
| -------- | ------------ | ------ |
| 記憶容量 | 非常に小さい | 大きい |
| 演算能力 | 有り         | 無し   |

ここで言う演算とは、足し算や引き算を含む様々な計算のことです。CPUは演算機能をもっていますが、ほんの少しの情報しか記憶できないので、CPUだけではちょっとしたプログラムも動かせません。そこで、まず容量の大きいメモリにプログラム全体を読み込ませます。プログラムは、CPUに対する命令の集まりです（と思って大体間違いありません）。CPUは、メモリに読み込んだ命令を１つずつ読み取って実行していきます。それでは、次に、プログラムなどの情報がどのようにメモリに保存されているのかを見ていきましょう。

## メモリの仕組み

メモリは、たとえば001011010110001101011...のように、全ての情報を0と1の並びに変換して記憶しています。この0と1の並びは、8桁ずつの区画に区切られています。それぞれの区画には、**アドレス**と呼ばれる数字が振られていて、数字によってメモリ上の位置が指定できるようになっています。

それぞれの区画には、8桁の0と1が格納されているので、1つの区画は00000000から11111111までの256通りの状態を記憶することができます。この記憶容量のことを**バイト**(Byte)といいます。一方、1桁の0と1で記憶できる容量のことを**ビット**(bit)と呼びます。よって、

1バイト = 8ビット

の関係が成り立ちます。

メモリへの情報の読み書きは、必ずバイトを単位として行われます。ビットを単位として読み書きすることはできません。このように、バイトはパソコンにおける最も重要な情報量の単位です。

![memory](img/memory.drawio.png)

メモリについて考えるときは、上図のように、バイト単位のデータが積み重なったものと考えると良いです。なお、バイトよりも大きい情報量の単位には、キロバイトやメガバイト、ギガバイトなどがあります。

| 情報量の単位    | バイト換算                  |
| --------------- | --------------------------- |
| キロバイト(KB)  | 10の3乗=1,000バイト         |
| メガバイト(MB)  | 10の6乗=1,000,000バイト     |
| ギガバイト(GB)  | 10の9乗=1,000,000,000バイト |
| キビバイト(KiB) | 2の10乗=1,024バイト         |
| メビバイト(MiB) | 2の20乗=1,048,576バイト     |
| ギビバイト(GiB) | 2の30乗=1,073,741,824バイト |

なお、キロバイト、メガバイト、ギガバイトという言葉が使われている場合でも、実際にはキビバイト(KiB)、メビバイト(MiB)、ギビバイト(GiB)を指す場合があるので、多少の注意が必要です。本講義でも、キビバイトやメビバイトは余り親しみのない言葉ですので、KiBやMiBと書いてキロバイト、メガバイトと発音しても良いことにします。ご注意ください。なおキビバイトとキロバイトの容量差は2%しかありませんので、通常この違いに神経質になる必要はありません。ギガバイトとギビバイトになると、7%の違いがありますので、ちょっと無視できないかもしれません。

## CPUの働き

一方、CPUは**レジスタ**と呼ばれる記憶装置を複数内臓しています。レジスタは、プログラム内の**命令**やデータ、メモリのアドレスなどを格納することができます。CPUはメモリに読み込まれたプログラムの中の命令をレジスタに読み込こんで実行したり、メモリのなかのデータをレジスタに読み込んで演算をほどこしたり、演算の結果をメモリに書き込んだりすることでコンピュータを動かしています。

レジスタにはプログラマがプログラムから直接操作できるもの(十数個ある)と操作できないものがあります。プログラマが意識しなくてはならないのは前者の操作できるレジスタだけです。具体的にどのようなレジスタがいくつあるのかについては、CPUによって違ってきます。

レジスタは、メモリと全く同じように0と1の情報を格納できます。レジスタには、64ビットコンピュータでは64ビット=8バイトの情報を格納することができます。32ビットコンピュータでは4バイトです。したがって、プログラムが一つのレジスタを使って一度に処理できるデータの量は64ビットコンピュータなら最大8バイト、32ビットコンピュータなら最大4バイトです。

ただし64ビットレジスタは下位の32ビットを使って32ビットレジスタとしても動作できるようになっています。従って、64ビットコンピュータでも、32ビット仕様のOSやアプリケーションが動作します。

32ビットレジスタのサイズが4バイトであることに合わせて、32ビットOSはメモリのアドレスを4バイトで表現します。

|            | 2進数表記     | 16進数表記 | 10進数表記              |
| ---------- | ------------- | ---------- | ----------------------- |
| 最小の数字 | 0b0           | 0x0        | 0                       |
| 最大の数字 | 0b1111...1111 | 0xffffffff | 4,294,967,295=2の32乗-1 |

0xffffffff=4,294,967,295=0b1111...1111であることはPythonで簡単に確かめることができます。

```python
>>> 0xffffffff
4294967295
>>> bin(0xffffffff)
'0b11111111111111111111111111111111'
```

4バイトの数値が表現できるメモリアドレスの範囲は、上記の表にあるように0～2の32乗-1=4×2の30乗-1です。メモリは1区画あたり1バイトの容量をもつので、32ビットOSでは、4×2の30乗バイト、すなわち4GiBまでしか扱うことができません。したがって、それ以上のメモリを物理的に搭載しても、4GiBを超える部分はOSによって認識してもらえません。

一方、64ビット対応したOSでは、メモリアドレスの表現に8バイト数値を使用します。したがって0～2の64乗-1までのアドレスを使うことができます。これは極めて巨大な数ですので、64ビットOSでは、実質任意に大きなメモリを使用できます。

## マシン語

プログラムがメモリに読み込まれたあと、プログラムを構成する命令は、一つずつCPUに読みだされて実行されていきます。

![register](img/register.drawio.png)

レジスタは0と1しか格納できないので、命令と命令からなるプログラムもまた、0と1の列でなくてはなりません。(当然、列の長さは8の倍数です。)こうした、CPUが理解できる、0と1で構成された命令を**マシン語**と呼びます。大昔、コンピュータができたばかりでプログラミング言語がまだ存在していなかったころは、プログラマはマシン語を直接編集することでプログラムを作っていました。

試しに、プログラムが実際にどのようなマシン語になっているかをディスプレイに打ち出してみることができます。これを**ダンプ**(dump)と言います。たとえば、画面に"Hello, World!"と打ち出すプログラムの最初の36バイトをダンプしてみると、以下のようになります。

```C
01111111 01000101 01001100 01000110 00000001 00000001
00000001 00000000 00000000 00000000 00000000 00000000
00000000 00000000 00000000 00000000 00000010 00000000
00101000 00000000 00000001 00000000 00000000 00000000
00010100 00000011 00000001 00000000 00110100 00000000
00000000 00000000 10100100 00011010 00000000 00000000
```

このように、マシン語は人間にとっては非常に分かりづらいので、マシン語を直接操作しなくてもプログラムが作れるように、C言語などのプログラミング言語が作られました。

余談ですが、64ビット版のWindows 10にはダンプをするためのツールが標準搭載されていないので、ダンプしたい人はそれ専用のツールを別途手に入れる必要があります。一方Linuxにはダンプのためのコマンドが標準で搭載されています。ターミナルで次のように入力すれば実行可能ファイルをダンプできます。

```shell
xxd -b a.out
```

ここでa.outが実行可能ファイルの名前です。-bは2進数でダンプするオプションです。このオプションを付けないと、結果は16進数で表示されます。

## プログラミング言語の種類

プログラミング言語を分類する方法は色々ありますが、まず覚えた方が良いのが、コンパイル型言語とインタープリタ型言語の違いです。

|                  | コンパイル型                  | インタープリタ型                      |
| ---------------- | ----------------------------- | ------------------------------------- |
| 実行速度         | 高速                          | 低速                                  |
| コンパイル要不要 | 必要                          | 不必要                                |
| 例               | C言語、C++、FORTRAN、RUSTなど | Python、R、Ruby、Perl、JavaScriptなど |

### コンパイル型言語

たとえばC言語のようなコンパイル型言語で"Hello, World!"を出力するプログラムについて考えましょう。その場合、まず次のようなプログラミング言語で書かれたテキストファイル（**ソースファイル**あるいは**ソースコード**という）を準備します。

```C
#include <stdio.h>
int main(){
  printf("Hello, World!\n");
  return 0;
}
```

このファイル名をhello.cとしましょう。その後、**コンパイル**という操作により、このファイルを機械語に変換します。この操作を実行するソフトウェアのことを**コンパイラ**と呼びます。たとえばLinuxには通常GNU C/C++ Compilerというコンパイラがインストールされていて、次のコマンドでコンパイルを行うことができます。

```shell
gcc hello.c
```

コンパイルを行うと、a.outという名前のマシン語で書かれたファイルが作成されます。これを**実行可能ファイル**と呼びます。厳密には、hello.cをマシン語にコンパイルしただけでは実行ファイルにはならず、**オブジェクトファイル**と呼ばれるマシン語で書かれたファイルが出来上がります。コンパイラはさらに**リンク**という作業を行い、出来上がったオブジェクトファイルに必要な付属品を色々とくっつけて実行可能ファイルを作ります。コンパイル型の言語で書かれたソースファイルは直接実行することはできず、かならずコンパイルして実行可能ファイルを作る必要があります。

![compile](img/compile.drawio.png)

実行可能ファイルは、CPUが直接解釈可能なマシン語で書かれているため、非常に高速に動作します。一方で、大きなプログラムはコンパイルに大変時間がかかるという欠点があります。また実行可能ファイルを構成するマシン語は、CPUのレジスタを直接操作する命令の集まりですので、CPUの異なるコンピュータでは動作しません。従って、プログラムを他のコンピュータに移植するときは、移植先のコンピュータでソースコードを再コンパイルする必要があります。

### インタープリタ型言語

一方、Pythonのようなインタープリタ型言語では、実行にコンパイルを必要としません。インタープリタ型言語では、ソースファイルは実行可能ファイルの源（ソース）ではないので、ソースファイルのことを**スクリプト**と呼ぶことがあります。また、インタープリタ型言語のことを**スクリプト言語**ということもあります。スクリプト言語では、スクリプトに記述されたコードは**インタープリタ**と呼ばれるプログラム(アプリケーション)によって一つずつ読み取られ、実行されていきます。

実際にはスクリプトファイルのテキスト文をそのまま読み取っていくのはインタープリタにとって不便なので、まずスクリプトはバイトコードと呼ばれるマシン語に似たものに変換されます。そのあと、バイトコードの中の命令が1行ずつ読み取られながらインタープリタによって実行されていくわけです。インタープリタはスクリプトからバイトコードを生成する作業と、バイトコードの命令を読み取って実行する作業を両方担当しています。Pythonインタープリタのうち、バイトコード実行を行う部分だけを指して、**Pythonヴァーチャルマシン**(PVM)と呼びます。

![pvm](img/python_image.drawio.png)

Pythonがバイトコードを生成するプロセスのことを**コンパイル**もしくは**バイトコンパイル**と呼ぶことがあるので注意が必要です。コンパイル言語でのコンパイルと違い、Pythonのバイトコンパイルは**マシン語を生成しません**。

試しに"Hello world!"と印字するPythonのプログラムをバイトコンパイルしてみましょう。まず、このプログラムのPythonスクリプトは次のようになります。

```python
print("Hello world!")
```

このコードをバイトコンパイルして出来たバイトコードの最初の36バイトをダンプすると、以下のようになります。

```C
01000010 00001101 00001101 00001010 00000000 00000000 
00000000 00000000 10101110 10001001 10011110 01100000
00011000 00000000 00000000 00000000 11100011 00000000 
00000000 00000000 00000000 00000000 00000000 00000000
00000000 00000000 00000000 00000000 00000000 00000010
00000000 00000000 00000000 01000000 00000000 00000000
```

よく似ていますが、これはバイトコードであり、マシン語ではありません。Pythonヴァーチャルマシンは、このバイトコードを実行していきます。

バイトコードの特徴は、マシン語で記述されたコンパイル言語の実行可能ファイルと違って、CPUの仕様に依存していないことです。したがって、バイトコードはそのまま他のコンピュータで実行することができます。一方で、直接レジスタに命令を送り込むコンパイル言語に比べると、ヴァーチャルマシンを介さなくてはならないスクリプト言語はかなり低速になり、場合によっては100～1000倍くらいの実行時の速度差が出てしまいます。

しかしながら、コンパイルの必要がないので、インタープリタ言語による開発時間はコンパイル言語よりもはるかに早いのが普通です。(たとえばC言語で書かれた非常に大きなプログラムですと、コンパイルだけで数時間～数日かかってしまうこともあります。)

このコンパイル型言語とインタープリタ型言語の違いを利用して、Python等のインタープリタ型言語でスピーディにプロトタイプを作成し、その後、少しずつコンパイル型言語に置き換えていくという開発上の作戦が取られることも良くあります。

もう一つ、皆さんに覚えておいて欲しいのは、インタープリタそれ自体がプログラムであり、これは通常コンパイル型言語で作成(実装)されているということです。たとえばPythonのインタープリタで最も一般的なのはC言語で実装されたCPythonというインタープリタで、ほとんどの方が使っているPythonはこれです。CPythonのソースコードは公開されているので誰でも読むことができ、C言語を知っていれば内容を理解できます。他にもJavaで実装されたJythonというインタープリタもあります。

### アセンブリ言語

なおプログラミング言語の中には、**アセンブリ言語**という特別なタイプの言語があります。アセンブリ言語は、01の並びであるマシン語を分かりやすい記号の列に「直訳」したものです。直訳したものですので、マシン語とアセンブリ言語はどちらの方向にでも変換可能です。アセンブリ言語からマシン語を生成する作業を**アセンブル**、その逆を**逆アセンブル**と言います。アセンブルを行うためのソフトウェアを**アセンブラ**と呼びます。アセンブリ言語の特徴の一つは、マシン語の直訳であるため、レジスタの操作をプログラマが明示的に行う必要があるということです。

たとえば、次のC言語のプログラムは、aという変数に1を代入し(正確には1という値で初期化し)、そのあとaに2を足すというだけのプログラムです。

```C
int MyAdd(){
  int a = 1;
  a = a + 2;
  return a;
}
```

これをコンパイルして出来たオブジェクトファイルを逆アセンブルすると、次のようなアセンブリ言語のコードが得られます。

```nasm
push   rbp
mov    rbp,rsp
mov    DWORD PTR [rbp-0x4],0x1
add    DWORD PTR [rbp-0x4],0x2
mov    eax,DWORD PTR [rbp-0x4]
pop    rbp
ret
```

![assembly](img/assemble.drawio.png)

アセンブリ言語にはいくつか方言がありますが、ここではNASM(Netwide Assembler)という表記を用いています。ここでは詳しく説明できませんが、上のコードにおいて、rbpやrsp、eaxは全てレジスタの名前を表します。このように、アセンブリ言語では、レジスタを直接操作することが必要になってきます。(ちなみに"DWORD PTR [RBP-0X4]"などはメモリの領域を表します。)

アセンブルと違って**コンパイルは不可逆変換**なので、実行可能ファイルからコンパイル前のソースコードを復元することはできません。従って実行可能ファイルを分析するときは、通常、逆アセンブルを行ってアセンブリ言語に翻訳し、これを読解していきます。例えば、コンピュータウィルスの性質を解析する際にこういったスキルが必要になります。

Linuxを使っている人は次のようにしてコンパイルと逆アセンブルを行うことができます。上のソースファイル名をmyadd.cとします。

```bash
gcc -c myadd.c
objdump -d -M x86-64,intel myadd.o
```

ここでmyadd.oはコンパイルによって生成されたオブジェクトファイルです。

## 抽象度

アセンブリ言語のように、レジスタやメモリといったハードウェアを直接操作する言語を**低水準言語**と呼びます。低水準言語は、**抽象度が低い言語**と表現されることもあります。一方、Pythonのように、レジスタやメモリと言ったものをプログラマが直接意識することなくプログラミングできるような言語は、**高水準言語**と呼ばれ、**抽象度が高い**と言われます。一般に、インタープリタ型言語のほうがコンパイル型言語よりも抽象度が高い傾向があります。また、時代が進むにしたがって、より高水準で抽象度の高い言語が登場してきたと言えます。

高水準言語や低水準言語というのは、相対的なものであるととらえた方が良いでしょう。たとえば、従来C言語はアセンブリ言語と比較して高水準言語であると言われてきましたが、言語の高水準化が進むにつれ、たとえばPython等に比べると低水準言語であると言われるようにもなってきました。というのも、C言語ではレジスタを意識することはほとんどありませんが、メモリはかなり意識しないとコードが書けないからです。一方、Pythonでは、C言語よりも抽象度が高く、比較的メモリを意識しなくてもプログラミングができるようになっています。それでも、以降の講義で論じるように、メモリをある程度意識することはPythonを正しく使う上で重要であると言えます。

## プログラミング上達のコツ

当たり前ですが、プログラミングの上達において最も大切なことは、「プログラミングを楽しむ」ことだと思います。そのために大切なことは、「ストレスなくコーディングする」ということに尽きると思います。そして、そのためには、以下の2点が重要であると筆者は考えます。

- 正しいタイピングをする
- エディターのキーバインドをマスターする

### 正しいタイピング

正しいタイピングとは、タッチタイピング（いわゆるブラインドタッチ）のことです。タッチタイピングを解説したサイトはインターネットにたくさんありますので、ここでは改めて解説しません。以下の項目に注意して練習を重ねてください。

- 最初は決して速く打とうとしてはいけない
- 同じキーはいつも同じ指で叩く
- キーを叩くときは、基本そのキーに最も近い指で叩く
- キーボードを見ないでタイプするトレーニングをする
- 人差し指～小指すべて使う

数字や記号はつらいので、まずはアルファベットだけキーボードを見ないで打てるようになるように練習しましょう。そのうち見ないで打てるキーの数が増えてきます。タイピングソフトなどは必要ありません。ゆっくりで良いので、タッチタイピングの基本を守りつつプログラミングや文書作成をしていれば、自然に上達していきます。

上達につれてタイプの速度は上がってきますが、目安として大体1分間に200タイプくらいでスピード的には十分ではないでしょうか。重要なのはストレスを無くすことであって、速度を上げることではありません。ゆっくりでもキーボードを見ずに正確に打てるようになれば、視線の移動がほとんど必要なくなるので、コーディング中に感じるストレスは圧倒的に小さくなります。

### キーバインドをマスターしよう

コーディングのストレスを軽減するには、正しいタイピングを心がけるだけでなく、キーバインドを覚えることが重要です。本講義で言うキーバインドとは、編集中に文書の中を移動したり、編集に関連する様々な機能を呼び出したりするためのキーボードショートカットのことです。

プログラミングの世界には大きく分けて、2種類のメジャーなキーバインドがあります。1つは**Emacsキーバインド**、もう一つは**viキーバインド**です。これらは、それぞれ、Emacs、viというエディターで用いられているキーバインドですが、多くのエディターでこれらの2つのキーバインドを使用することができるようになっています。

**Emacsキーバインド**は直観的で覚えやすいのが特徴で、**viキーバインド**は「速い」のが特徴です。筆者はプログラミングにEmacs、設定ファイルなどの編集にviを使うという風に使い分けていますので、本講義でもプログラミングのためにはEmacsキーバインドを用いることを推奨したいと思います。Emacsキーバインドについては次回VS Codeを操作するときに詳しく説明します。

## まとめ

今回は、以下の事項について学びました。

- Pythonを学ぶ意義
- Pythonを動かす2種類の基本的な方法
- 本講義の目標
- プログラムがどのように動いているか
- プログラミング言語にはどのようなものがあるか
- プログラミング上達のコツ

今回の講義でPythonのプログラムがどのように動いているか、大体分かったと思います。一方で、一つ一つのPythonの文がどのように動作しているのかまでは説明しませんでした。そういった詳細については今後の講義で解き明かして行くことにしましょう。

基本的なプログラミングの練習は、基本的に独学でも可能なものです。自宅や研究室のパソコンにもPythonをインストールし、教科書を参照しながらPythonの操作をしっかりと練習しておいてください。

## 参考書

- [『プログラムはなぜ動くのか(第2版)』](https://www.amazon.co.jp/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0%E3%81%AF%E3%81%AA%E3%81%9C%E5%8B%95%E3%81%8F%E3%81%AE%E3%81%8B-%E7%AC%AC%EF%BC%92%E7%89%88-%E7%9F%A5%E3%81%A3%E3%81%A6%E3%81%8A%E3%81%8D%E3%81%9F%E3%81%84%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0%E3%81%AE%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98-%E7%9F%A2%E6%B2%A2%E4%B9%85%E9%9B%84/dp/4822283151/ref=tmm_pap_swatch_0?_encoding=UTF8&qid=1618632158&sr=8-1)(矢沢久雄 著/日経ソフトウェア監修) (2007) 日経BP社. ISBN 978-4-8222-8315-5.

## 宿題（ホームワーク）

本講義では提出しなくてよい宿題のことを「宿題」または「ホームワーク」と呼ぶことにします。今回はホームワークとして、以下を出題します。

1. 『独習Python』の第1章『イントロダクション』を読みなさい。
2. そこに書かれている手順に従って、AnacondaとVS Codeを自分のパソコンもしくは研究室のパソコンにインストールしなさい。
3. AnacondaをインストールしたパソコンでIPythonを起動し、様々な計算式を打ち込んでみなさい。
4. もしあなたが十分に野心的ならば、IPythonに様々なPythonコードを打ち込み、期待された結果が得られるか試してみなさい。

なお、LinuxユーザーはAnacondaを**インストールしない**ことをお勧めします。下手するとX Windowシステムが壊れて再起不能になります。

また、スペック要件として、CPUはIntel Core i5以上(推奨Core i7もしくはRyzen 7)、メモリは最低でも8GBは必要かと思います(16GB推奨)。

## 課題（アサインメント）

本講義では、提出しなければならない宿題のことを「課題」もしくは「アサインメント」と呼ぶことにします。今回の課題はありません。課題は全てGitHubのアサインメント機能を使って提出していただきますので、課題が出題されるのはGitHubについて学ぶ第3回目以降です。
