# 第1回 プログラミング概論

- [第1回 プログラミング概論](#第1回-プログラミング概論)
  - [授業で使う言語](#授業で使う言語)
  - [なんでいまさらPython？](#なんでいまさらpython)
  - [深ぼりして何がうれしい？](#深ぼりして何がうれしい)
  - [本講義の目標](#本講義の目標)
  - [コンピューターの仕組み](#コンピューターの仕組み)
  - [メモリの仕組み](#メモリの仕組み)
  - [CPUの仕組み](#cpuの仕組み)
  - [マシン語](#マシン語)
  - [プログラミング言語の種類](#プログラミング言語の種類)
    - [コンパイル型言語](#コンパイル型言語)
    - [インタープリタ型言語](#インタープリタ型言語)
    - [アセンブリ言語](#アセンブリ言語)
  - [抽象度](#抽象度)
  - [対話的インタープリタを試す](#対話的インタープリタを試す)
  - [IPythonを触ってみよう](#ipythonを触ってみよう)
  - [プログラミング上達のコツ](#プログラミング上達のコツ)
    - [正しいタイピングをしよう](#正しいタイピングをしよう)
    - [キーバインドをマスターしよう](#キーバインドをマスターしよう)
  - [参考書](#参考書)
  - [ホームワーク](#ホームワーク)
  - [課題（アサインメント）](#課題アサインメント)

## 授業で使う言語

この授業は、プログラミングの授業です。
プログラミングの授業であるからには、少なくとも１つのプログラミング言語を扱わねばなりません。
この授業では、主にPythonを扱っていくことにします。それから、Rも少し扱っていきますが、Rについては、皆さんは統計学2や計量経済学（どちらも2年生科目)の授業で学んで来ているでしょうから、その基礎は押さえていると仮定し、いちいち復習はしません。たとえば、Rのベクトルやデータフレームがどういったものだったか忘れてしまっている人がいたら、復習しておいてください。それから、if条件分岐やforループについて、構文を忘れてしまっている人は、思い出しておくと良いでしょう。

さて、Pythonについては多くの方が名前くらい聞いたことがあるでしょう。触ったことがある人もおられることでしょう。以前はPythonの国内人気はいまいちでしたが、ここ10年ほどで機械学習ブームの波にのって人気が高まり、いまでは世界で最もポピュラーなプログラミング言語となりました。従って、YouTubeなどに、初心者向けのPythonのわかりやすい解説動画がたくさんあり、また独学に適した日本語の参考書も次々と発売されています（本講義で教科書として用いる『独習Python』もまたそうした書籍の一つであり、2020年に発売されたばかりです）。

## なんでいまさらPython？

独学のための良質の素材があふれているのであれば、なぜ本講義でわざわざプログラミング、そしてPythonを学ばなければならないのでしょうか。以下に、ちまたの教材に任せきってしまうことの問題を挙げてみましょう。

- 独学では、モチベーションが沸かない。
- 研究での活用がわかりにくい。
- 表面的な説明がおおく、Pythonの深いところがなかなか見えてこない。
- 高度な内容をどうやって勉強したらいいのかわからない。

こういったところでしょうか。要するに、とりあえずPythonを動かすことは独学で簡単にできるようになるのですが、そこから先（深ぼりしたり、応用したり）が見えないのです。先が見えないものは勉強したくないでしょう。

## 深ぼりして何がうれしい？

では、なぜPythonを深ぼりする必要があるのでしょうか？それは、Pythonが、深ぼりしないと間違いを冒すタイプの言語だからです。言い換えると、プログラムというものがどのように情報を扱っているのかをある程度理解しないと、Pythonを正しく使うことは難しいと言えます。その意味では、実はPythonは初学者向けの言語ではないと筆者は考えています。

これは見方を変えると、Pythonを正しく理解すれば、その過程でプログラミングへの理解がずっと深まるということです。この点で、PythonはRとかなり違います。Rは、プログラミングにそれほど精通していなくても使いやすく設計されています。Rに慣れた学生の皆さんは、Pythonを深く学ぶことで、プログラミングというものが何なのか、より深い実感をもつことができるようになるでしょう。

## 本講義の目標

それでは前置きが長くなりすぎたので、そろそろPythonを動かしてみましょう。ウィンドウズを起動して、画面の左下の検索ウィンドウにAnacondaと打ち込んで、Anaconda Promptを起動しましょう（Anaconda Powershell Promptでも構いません）。Anacondaを起動したら、pythonと入力し、pythonの対話的インタープリタを起動しましょう。プロンプトと呼ばれる>>>記号が現れて、入力待ちの状態になるはずです。

普通でしたら、pythonのインタープリタを初めて起動したら、「計算機として使ってみましょう」「Hello worldと出力してみましょう」といった風に進むのでしょうが、本講義は、ある程度プログラミングの経験のある人を対象にしていますし、それに本講義の目標をはっきりさせるためにも、あえてここでは少し高度なことをしてみましょう。
「xという変数に1234という整数を代入する」というおなじみのコードを書いてみましょう。これにより、pythonは、xという記号に1234という値を結びつけることができ、プログラマは、1234の代わりにxという記号を使うことができるようになるわけです。pythonでこれを実装すると次のようになります。

```python
>>> x = 1234
```

さて、本講義の前半部分（第7回目まで)では、**この一行のPython文において何が起こっているのかを理解すること**を目標にしたいと思います。Pythonには余りにもたくさんの機能があって、それらを網羅的に把握するのは至難の技です（また残念ながら筆者にはそこまでの知識がありません）。それよりは目標を絞ったほうが良いというのが筆者の考えです。

また、上記の代入文はもっとも基本的なPythonの文ですから、これを理解せずにPythonプログラマになるのも難しいように思います。もちろん理解していなくても、どんどんPythonを使ってみるべきです。むしろ、上の代入文で何が起きているのかを大体でも良いので説明できるようになるまでには、かなりの量のプログラミングを行い、実験を重ねなければならないのではないかと思います。残念ながら本講義だけでは、上の代入文を完全に説明しきることはできません。それでも、そこらへんの入門書を2~3冊読み終えた人と同程度には、理解できるようになることを目指したいと思います。

さて、上記の代入文が入力されるとき、一体何が起きているのかを理解するためには、まず、コンピュータが1やxといった情報をどのように扱っているのかの説明から始める必要があります。

## コンピューターの仕組み

パソコンは、様々な部品から構成されていますが、プログラミングの初心者がまず知っておかなければならないのが、CPUとメインメモリの働きです。メインメモリはランダムアクセスメモリ(Random Access Memory)とも呼ばれるので、RAMと表記されることもあります。

CPUとメモリは、記憶装置です。パソコンにはいくつもの記憶装置が内臓されていますが、どの記憶装置も、文字や整数や少数だけでなく、プログラムなど、すべての情報を0と1の配列に変換して記憶しています。

CPUとメモリはどちらもトランジスタで構成された集積回路(IC, Integrated Circuit)ですが、次のような性質の違いがあります。

||CPU|メモリ|
|--|--|--|
|記憶容量|非常に小さい|大きい|
|演算能力|有り|無し|

ここで言う演算とは、足し算や引き算を含む様々な計算のことです。CPUは演算機能をもっていますが、ほんの少しの情報しか記憶できないので、CPUだけではちょっとしたプログラムも動かせません。そこで、まず容量の大きいメモリにプログラム全体を読み込ませます。プログラムは、CPUに対する命令の集まりです（と思って大体間違いありません）。CPUは、メモリに読み込んだ命令を１つずつ読み取って実行していきます。それでは、次に、プログラムなどの情報がどのようにメモリに保存されているのかを見ていきましょう。

## メモリの仕組み

メモリは、たとえば001011010110001101011...のように、全ての情報を0と1の並びに変換して記憶しています。この0と1の並びは、8桁ずつの区画に区切られています。それぞれの区画には、**アドレス**と呼ばれる数字が振られていて、数字によってメモリ上の位置が指定できるようになっています。

それぞれの区画には、8桁の0と1が格納されているので、1つの区画は00000000から11111111までの128通りの状態を記憶することができます。この記憶容量のことを**バイト**(Byte)といいます。一方、1桁の0と1で記憶できる容量のことを**ビット**(bit)と呼びます。よって、

1バイト = 8ビット

の関係が成り立ちます。

メモリへの情報の読み書きは、必ずバイトを単位として行われます。ビットを単位として読み書きすることはできません。このように、バイトはパソコンにおける最も重要な情報量の単位です。

![](img/memory.drawio.png)

メモリについて考えるときは、上図のように、バイト単位のデータが積み重なったものと考えると良いです。なお、バイトよりも大きい情報量の単位には、キロバイトやメガバイト、ギガバイトなどがあります。

|情報量の単位|バイト換算|
|--|--|
|キロバイト(KB)|10の3乗=1,000バイト|
|メガバイト(MB)|10の6乗=1,000,000バイト|
|ギガバイト(GB)|10の9乗=1,000,000,000バイト|
|キビバイト(KiB)|2の10乗=1,024バイト|
|メビバイト(MiB)|2の20乗=1,048,576バイト|
|ギビバイト(GiB)|2の30乗=1,073,741,824バイト|

なお、キロバイト、メガバイト、ギガバイトという言葉が使われている場合でも、実際にはキビバイト(KiB)、メビバイト(MiB)、ギビバイト(GiB)を指す場合があるので、多少の注意が必要です。本講義でも、キビバイトやメビバイトは余り親しみのない言葉ですので、KiBやMiBと書いてキロバイト、メガバイトと発音しても良いことにします。ご注意ください。なおキビバイトとキロバイトの容量差は2%しかありませんので、通常この違いに神経質になる必要はありません。ギガバイトとギビバイトになると、7%の違いがありますので、ちょっと無視できないかもしれません。

## CPUの仕組み

一方、CPUは内部にレジスタと呼ばれる小さな記憶装置を数十個程度内臓しています。(レジスタには色んな種類があって役割分担をしていますが、初心者にとってそういった詳細は重要ではありません。)CPUはメモリに読み込まれたプログラムの中の命令を一つずつレジスタに読み込こんで実行したり、メモリのなかのデータをレジスタに読み込んで演算をほどこしたりすることでコンピュータを動かしています。

レジスタは、メモリと全く同じように0と1の情報を格納できます。1つのレジスタには、64ビットコンピュータでは64ビット=8バイトの情報を格納することができます。今はもうほとんどありませんが、32ビットコンピュータでは4バイトです。したがって、CPUが一度に処理できるデータの量は64ビットコンピュータなら最大8バイト、32ビットコンピュータなら最大4バイトです。

CPUで処理されるあらゆる情報はレジスタに読み込まれます。当然、命令やデータだけでなく、メモリのアドレスもまた必要に応じてレジスタに読み込まれることがあります。したがって、メモリのアドレスは、32ビットコンピュータでは、4バイトのレジスタに格納できる範囲の数値に収まっていなければなりません。4バイトで表現できる数値の範囲は以下の通りです。

||2進数表記|16進数表記|10進数表記|
|--|--|--|--|
|最小の数字|0b0|0x0|0|
|最大の数字|0b1111...1111|0xffffffff|4,294,967,295=2の32乗-1|

32ビットレジスタが操作できるメモリアドレスの範囲は、上記の表にあるように0～2の32乗-1=4×2の30乗-1です。メモリは1区画あたり1バイトの容量をもつので、32ビットコンピュータでは、4×2の30乗バイト、すなわち4GiBまでしか扱うことができません。したがって、それ以上のメモリを搭載しても、4GiBを超える部分は認識してもらえません。

一方、64ビットコンピュータでは、レジスタは8バイトを格納できるので、10進数表記で0～2の64乗-1までのアドレスを使うことができます。これは極めて巨大な数ですので、64ビットコンピュータでは、実質任意に大きなメモリを搭載することができます。

ちょっと難しかったかもしれませんが、ここでは、皆さんが使っている64ビットのパソコンでは、**メモリのアドレスは8バイトの数値で表される**ことを覚えておきましょう。これが後々重要になってきます。

## マシン語

プログラムがメモリに読み込まれた（**ロード**されるということもあります）あと、プログラムを構成する命令は、一つずつ命令レジスタと呼ばれるレジスタに格納され、実行されていきます。レジスタは0と1しか格納できないので、命令と命令からなるプログラムもまた、0と1の列でなくてはなりません。(当然、列の長さは8の倍数です。)こうした、CPUが理解できる、0と1で構成された命令を**マシン語**と呼びます。大昔、コンピュータができたばかりでプログラミング言語がまだ存在していなかったころは、プログラマはマシン語を直接編集することでプログラムを作っていました。

試しに、プログラムが実際にどのようなマシン語になっているかをディスプレイに打ち出してみることができます。これを**ダンプ**(dump)と言います。たとえば、画面に"Hello world!"と打ち出すプログラムの最初の36バイトをダンプしてみると、以下のようになります。

```C
01111111 01000101 01001100 01000110 00000001 00000001
00000001 00000000 00000000 00000000 00000000 00000000
00000000 00000000 00000000 00000000 00000010 00000000
00101000 00000000 00000001 00000000 00000000 00000000
00010100 00000011 00000001 00000000 00110100 00000000
00000000 00000000 10100100 00011010 00000000 00000000
```

マシン語は人間にとっては非常に扱いづらいので、マシン語を直接操作しなくてもプログラムが作れるように、C言語などのプログラミング言語が作られました。

## プログラミング言語の種類

プログラミング言語を分類する方法は色々ありますが、まず覚えた方が良いのが、コンパイル型言語とインタープリタ型言語の違いです。
||コンパイル型|インタープリタ型|
|--|--|--|
|実行速度|高速|低速|
|コンパイル要不要|必要|不必要|
|対話的実行|不可|可|
|例|C言語、C++、FORTRAN、RUSTなど|Python、R、Ruby、Perl、JavaScriptなど|

### コンパイル型言語

たとえばC言語のようなコンパイル型言語で"Hello world!"を出力するプログラムについて考えましょう。その場合、まず次のようなプログラミング言語で書かれたテキストファイル（**ソースファイル**あるいは**ソースコード**という）を準備します。

```C
#include <stdio.h>
int main(){
  printf("Hello world!\n");
  return 0;
}
```

このファイル名をhello.cとしましょう。その後、**コンパイル**という操作により、このファイルを機械語に変換します。この操作を実行するソフトウェアのことを**コンパイラ**と呼びます。たとえばLinuxには通常GNU C/C++ Compilerというコンパイラがインストールされていて、次のコマンドでコンパイルを行うことができます。

```shell
gcc test.c
```

コンパイルを行うと、a.outという名前のマシン語で書かれたファイルが作成されます。これを**実行可能ファイル**と呼びます。コンパイル型の言語で書かれたソースファイルは直接実行することはできず、かならずコンパイルして実行可能ファイルを作る必要があります。

実行可能ファイルは、CPUが直接解釈可能なマシン語で書かれているため、非常に高速に動作します。一方で、大きなプログラムはコンパイルに大変時間がかかるという欠点があります。また実行可能ファイルを構成するマシン語は、CPUのレジスタを直接操作する命令の集まりですので、CPUの異なるコンピュータでは動作しません。従って、プログラムを他のコンピュータに移植するときは、移植先のコンピュータでソースコードを再コンパイルする必要があります。

### インタープリタ型言語

一方、Pythonのようなインタープリタ型言語では、実行にコンパイルを必要としません。インタープリタ型言語では、ソースファイルは実行可能ファイルの源（ソース）ではないので、ソースファイルのことを**スクリプト**と呼ぶことがあります。また、インタープリタ型言語のことを**スクリプト言語**ということもあります。スクリプト言語では、スクリプトに記述されたコードは**インタープリタ**と呼ばれるアプリケーションによって一つずつ読み取られ、インタープリタによって実行されていきます。その際、インタープリタは読み取った命令を一つ一つマシン語に変換して逐次的にCPUに渡していきます。

実際にはスクリプトファイルのテキスト文をそのまま読み取っていくのはインタープリタにとって不便なので、まずスクリプトはバイトコードと呼ばれるマシン語に似たものに変換されます。そのあと、バイトコードの中の命令が1行ずつ読み取られながら、マシン語に変換されて実行されていくわけです。インタープリタはスクリプトからバイトコードを生成する作業と、バイトコードを逐次的にマシン語に変換して実行する作業を両方担当しています。

バイトコードの特徴は、マシン語で記述されたコンパイル言語の実行可能ファイルと違って、CPUの内部仕様(アーキテクチャ)に依存していないことです。したがって、バイトコードはそのまま他のコンピュータで実行することができます。一方で、逐一マシン語に変換しながら実行しなくてはならないので、コンパイル言語に比べるとスクリプト言語はかなり低速になり、場合によっては100～1000倍くらいの実行時の速度差が出てしまいます。

しかしながら、コンパイルの必要がないので、開発時間はインタープリタ言語の方がはるかに早いのが普通です。(非常に大きなプログラムですと、コンパイルだけで数時間～数日かかってしまうこともあります。)これは納期の短い案件では非常に有利に働く特徴と言えます。

このコンパイル型言語とインタープリタ型言語の違いを利用して、Python等のインタープリタ型言語でスピーディにプロトタイプを作成し、その後、少しずつコンパイル型言語に置き換えていくという開発上の作戦が取られることも良くあります。

もう一つ、皆さんに覚えておいて欲しいのは、インタープリタそれ自体がプログラムであり、これは通常コンパイル型言語で作成されているということです。たとえばPythonのインタープリタで最も一般的なのはC言語で実装されたCPythonというインタープリタです。CPythonのソースコードは一般に公開されているので誰でも読むことができ、C言語を知っていれば内容を理解できます。インタープリタのソースコードを読むと、Pythonの様々な機能がどのように実装されているのかが深く理解できるので、非常に有意義であると言えます。(実際本講義の準備でも情報源としてしばしばソースコードを参照しました。）他にもJavaで実装されたJythonというインタープリタもあります。中にはPythonで実装されたPyPyという変わったPythonのインタープリタもあります。

### アセンブリ言語

なおプログラミング言語の中には、**アセンブリ言語**という特別なタイプの言語があります。これは、01の並びであるマシン語を分かりやすい記号の列に「直訳」したものです。直訳したものですので、マシン語とアセンブリ言語はどちらの方向にでも変換可能です。アセンブリ言語からマシン語を生成する作業を**アセンブル**、その逆を**逆アセンブル**と言います。アセンブルを行うためのソフトウェアを**アセンブラ**と呼びます。アセンブリ言語の特徴の一つは、マシン語の直訳であるため、レジスタの操作をプログラマが明示的に行う必要があるということです。

## 抽象度

## 対話的インタープリタを試す

## IPythonを触ってみよう

## プログラミング上達のコツ

### 正しいタイピングをしよう

### キーバインドをマスターしよう

プログラミングの上達には、正しいタイピングを心がけるだけでなく、キーバインドを覚えることが重要です。本講義で言うキーバインドとは、編集中に文書の中を移動したり、編集に関連する様々な機能を呼び出したりするためのキーボードショートカットのことです。

プログラミングの世界には大きく分けて、2種類のメジャーなキーバインドがあります。1つは**Emacsキーバインド**、もう一つは**viキーバインド**です。これらは、それぞれ、Emacs、viというエディターで用いられているキーバインドですが、多くのエディターでこれらのキーバインドを使用することができます。

**Emacsキーバインド**は直観的で覚えやすいのが特徴で、**viキーバインド**は「速い」のが特徴です。筆者はプログラミングにEmacs、設定ファイルなどの編集にviを使うという風に使い分けていますので、本講義でもプログラミングのためにはEmacsキーバインドを用いることを推奨したいと思います。具体的なキーバインドの内容については次回VS Codeを操作するときに説明しましょう。

## 参考書

- [『プログラムはなぜ動くのか(第2版)』](https://www.amazon.co.jp/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0%E3%81%AF%E3%81%AA%E3%81%9C%E5%8B%95%E3%81%8F%E3%81%AE%E3%81%8B-%E7%AC%AC%EF%BC%92%E7%89%88-%E7%9F%A5%E3%81%A3%E3%81%A6%E3%81%8A%E3%81%8D%E3%81%9F%E3%81%84%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0%E3%81%AE%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98-%E7%9F%A2%E6%B2%A2%E4%B9%85%E9%9B%84/dp/4822283151/ref=tmm_pap_swatch_0?_encoding=UTF8&qid=1618632158&sr=8-1)(矢沢久雄 著/日経ソフトウェア監修) (2007) 日経BP社. ISBN 978-4-8222-8315-5.

## ホームワーク

本講義では提出しなくてよい宿題のことを「ホームワーク」と呼ぶことにします。今回はホームワークとして、以下を出題します。

1. 『独習Python』の第1章『イントロダクション』を読みなさい。
2. そこに書かれている手順に従って、AnacondaとVS Codeを自分のパソコンもしくは研究室のパソコンにインストールしなさい。
3. AnacondaをインストールしたパソコンでIPythonを起動し、様々な計算式を打ち込んでみなさい。
4. もしあなたが十分に野心的ならば、IPythonに様々なPythonコードを打ち込み、期待された結果が得られるか試してみなさい。

なお、LinuxユーザーはAnacondaを**インストールしない**ことをお勧めします。下手するとX Windowシステムが壊れて再起不能になります。

また、スペック要件として、CPUはIntel Core i5以上(推奨Core i7もしくはRyzen 7)、メモリは最低でも8GBは必要かと思います(16GB推奨)。

## 課題（アサインメント）

本講義では、提出しなければならない宿題のことを「課題」もしくは「アサインメント」と呼ぶことにします。今回の課題はありません。課題は全てGitHubのアサインメント機能を使って提出していただきますので、課題が出題されるのはGitHubについて学ぶ第3回目以降です。
