# 第6回 標準ライブラリ

## 標準ライブラリとは

標準ライブラリとは、Pythonをインストールしたときに最初から使うことのできる一連のデータ型、関数、オブジェクトなどを差し、インタープリタに組み込まれているものとモジュールで提供されるものがあります。(ただし、モジュールの中にはビルトインモジュールというインタープリタと切り離せないモジュールもあります。mathやsysがそういった例です。**ビルトイン**は**組込み**を意味します。)実際上は、標準ライブラリといえば、追加のインストール無しで使えることが保証されているものと言った程度の理解で十分です。

## イテラブル

イテラブルなデータ型とは、大雑把にいうと、forループの繰り返し処理においてループインデックスの範囲指定に用いることができるデータ型です。つまり

```python
for i in index_range:
  print(i)

```

のようなコードでindex_rangeのところに配置できるものです。(イテラブルのより正確な定義は[iterable](https://docs.python.org/ja/3/glossary.html#term-iterable)を参照。)

組込みデータ型でイテラブルなものには主に次のようなものがあります。

- コンテナ
  - シーケンス
    - リスト(list)
    - タプル(tuple)
    - レンジ(range)
  - 集合(set)
  - 辞書(dict)
- 文字列(str)
- バイト(bytes)

これらのデータ型には、ミュータブルなもの・イミュータブルなもの、インデックスやキーによって要素を取得できるもの・できないものといった違いがあります。

バイト型はあまり使う機会がないと思いますので、それ以外の型について解説します。

## リスト

リストについては前回の講義でかなり詳しく解説しました。リストはミュータブルで、インデックスやスライス記法によって要素が取得可能です。そのほか、前回詳解したcopyの他に、様々なメソッドを搭載しており、要素の編集を行うことができます。たとえばappendメソッドは、リストの末尾に要素を追加します。

```python
>>> x = [1,2,3]
>>> x.append(4)
>>> x
[1, 2, 3, 4]
```

ここでは、xの末尾に4という値を付け足しています。

そのほか、+演算子を用いて複数のリストを結合することが可能です。

```python
>>> x = [1,2,3]
>>> y = x + [4,5,6]
>>> y
[1, 2, 3, 4, 5, 6]
>>> x
[1, 2, 3]
```

ただし、この場合はappendメソッドと違って、もとのオブジェクトx自体は変更されていないことに注意してください。

リストを*演算子で掛け算することもできます。

```python
>>> x = [1]*10
>>> x
[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
```

ただし、*演算子は対象リストをシャローコピーして繋げるだけであることに注意しなくてはなりません(教科書のp.212参照)。つまり、次のようなことが起きます。

```python
>>> x = [[1,2]]*5
>>> x
[[1, 2], [1, 2], [1, 2], [1, 2], [1, 2]]
>>> x[0][1] = 5   # 第1の要素だけ変更したつもり
>>> x   # だが全ての要素が変わってしまった
[[1, 5], [1, 5], [1, 5], [1, 5], [1, 5]]
```

リストについてはこれ以上の説明は省略しますが、教科書のセクション6.1に様々な操作が載っていますので、よく読んでおいてください。

## タプル

タプルは、リストと同じくシーケンス型に分類されるイミュータブルなデータ型です。タプルは、リストをイミュータブルにしたものと考えてほとんど間違いありません。タプルはリストと同じく、要素オブジェクトへの参照を格納しています。

イミュータブルなので、要素への代入操作は禁止されています。

```python
>>> x = ('foo','bar','baz')
>>> x[0] = 'Python'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
```

注意しなくてはならないのは、タプルのようなイミュータブルなコンテナ型というのは、要素への参照の変更が禁止されているだけで、参照先の要素オブジェクトの変更は禁止されていないということです。したがって、タプルはイミュータブルですが、次のように要素オブジェクトに変更を加えることは可能です。

```python
>>> x = ('foo','bar',['baz'])
>>> x[2].append('BAZ')
>>> x
('foo', 'bar', ['baz', 'BAZ'])
```

リストと同じくタプルはインデクシングやスライス記法を受け付けます。

```python
>>> x = (1,2,3,4,5)
>>> x[1:4]
(2, 3, 4)
>>> x[3]
4
>>> x[:]
(1, 2, 3, 4, 5)
```

なお、一つしか要素のないタプルを作るためには、次のように、余分なカンマが一つ必要です。

```python
>>> x = (1,)    # 一つしか要素のないタプル
>>> x
(1,)
>>> type(x)
<class 'tuple'>
>>> x = (1)     # これだとただの整数
>>> x
1
>>> type(x)
<class 'int'>
```

なおここで用いたtype関数は引数にあたえたオブジェクトの型をしらべるビルトイン関数です。

リストと比べたときのタプルの利点としては、それが辞書のキーとして用いることができるということです。これについては次に詳しく述べます。

## 辞書(ディクショナリ)

リストと同じく、複数のPythonオブジェクトをまとめるための構造に、辞書(ディクショナリ)があります。辞書はPythonにおいて重要なデータ構造なので、特に詳しく説明しましょう。

リストでは、要素にアクセスするさいにインデックスを用いました。

```python
>>> x = ['foo','bar','baz']
>>> print(x[1])
bar
```

一方、辞書では、要素にアクセスするさいに、インデックスではなくキーを用います。キーには整数だけでなく文字列のようなPythonオブジェクトを指定できます。

```python
>>> x = {'foo':123,'bar':456,'baz':789}
>>> x
{'foo': 123, 'bar': 456, 'baz': 789}
>>> x['bar']
456
```

実際には、キーに指定できるのは、全ての**ハッシュ可能な**Pythonオブジェクトです。

>あるアルゴリズムによってオブジェクトを数字に変換することをハッシュ化と呼びます。ハッシュ化によって得られる数値をハッシュ値と呼び、当のアルゴリズムをハッシュ関数と呼びます。(Gitのところで出てきましたね。）ハッシュに変換できるオブジェクトをハッシュ可能(hashable)であると言います。

リストや集合といったミュータブルなビルトインオブジェクトはハッシュ可能ではありません。数値や文字列などイミュータブルなビルトインオブジェクトはほとんど全てハッシュ可能ですが、例外はあります。

```python
>>> x = {}
>>> x[(1,2,3)]=123
```

```python
>>> x = {}
>>> x[(1,2,[3])]=123
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unhashable type: 'list'
```

一つ目の例ではタプルをキーに指定していますが、全く問題ありません。一方二つ目の例でもタプルをキーにしていますが、このタプルは[3]というハッシュ不可能な要素(リスト)を持っているため、ハッシュ可能ではありません。タプルがハッシュ可能であるためには、そのすべての要素がハッシュ可能である必要があります。

## ハッシュ表

それでは、再び次のコードを例に、辞書を作成する際に何が起きているのかを見ていきましょう。

```python
>>> x = {'foo':123,'bar':456,'baz':789}
```

上のコードを実行すると、Pythonは232バイトのメモリ領域を確保します（具体的なバイト数は処理系やPythonのヴァージョンに依存します）。

```python
>>> import sys
>>> sys.getsizeof(x)
232
```

この232バイトのうち、104バイトは参照カウンタなどを含むオーバーヘッド部分であり、重要ではありません。重要なのは残り128バイトです。この128バイトは、**ハッシュ表(ハッシュテーブル)**というデータ構造を格納しています。ハッシュ表の役割は、キーオブジェクトを、要素オブジェクト（キーに対して**値**ともいいます）に対応付けることです。

最近のバージョンのPythonでは、ハッシュ表はインデックス表とエントリー表という二つの部分から構成されています(本講義では仮にそのように呼ぶことにします)。インデックス表は、1区画1バイトからなる8区画の一続きのメモリ領域で、合計8バイトを占有しています。一方エントリー表は、1区画24バイトからなる5区画の一続きのメモリ領域で、合計120バイトを占有しています。

次に、Pythonは第一のキーオブジェクト'foo'をハッシュ化します。やや不正確ではありますが、本質的に同じことをやってみましょう。

```python
>>> hash("foo")
531872228806607122
>>> hash("foo") & 0b111
2
```

上のコードでは、hash関数で'foo'をハッシュ化し、下3ビットを取り出しています。Pythonは、キーオブジェクト'foo'（のアドレス）、値オブジェクト123（のアドレス）、そしてキーのハッシュ値（上記の値）をセットにしてエントリー表の第0番目に記録します。キー・値・ハッシュ値がそれぞれ8バイトずつ占有するので、合計8×3=24バイトで1区画を占有します。

次に、ハッシュ値の下3桁をみると、0b010=2ですので、Pythonは、インデックス表の2番目の区画に、0を記録します。これにより、キー'foo'に対応する情報は、エントリー表の0番目の区画に記録されているということが分かるようになります。同じことを、'bar'と'baz'に対しても行うと、図のようなインデックス表とエントリー表ができあがります(ハッシュ化により'bar'は0b110=6、'baz'は0b001=1を割り当てられる）。

```python
>>> hash("bar")
-1001163682187755818
>>> hash("bar") & 0b111
6
>>> hash("baz")
2724165034148455057
>>> hash("baz") & 0b111
1
```

さて、次のようなコードを実行したとしましょう。

```python
# xは定義済み
>>> print(x['baz'])
789
```

このとき、Pythonは、まずキーオブジェクト'baz'をハッシュ化して、その2進数表記の下3桁をとりだします。すると0b001=1という値でしたので、インデックステーブルの1番目の要素を探します。すると、2という値が記録してあるので、エントリーテーブルの2番目の要素をチェックし、そこに'baz'と789が登録されていることを確認します。このようにして、値789を取り出し、print関数で印字しているということになります。

なお、ハッシュ化して下3桁をとると、複数のキーが同じインデックスになってしまうことがあります。これを**ハッシュ衝突**と呼びます。二つのキーでハッシュ衝突が起きると、後からやってきたキーは適当なアルゴリズムで別のインデックスを振られます（このアルゴリズムに興味がある人は、自分で調べてみましょう）。

インデックス表が埋まってくると、だんだんと衝突の確率が上がってきます。衝突が多いほど、登録にも検索にも時間がかかるようになります。ですので、衝突を最小限に抑えるために、インデックス表の区画数はエントリー表よりもすこし大きめに確保してあります。エントリー表が満杯になると、インデックス表とエントリー表が両方とも拡張されます。このとき、エントリー表のサイズは10区画、インデックス表のサイズは16区画に拡張されます。再びエントリー表が一杯になると、再度拡張がおき、今度はエントリー表は21区画、インデックス表は32区画になります。このようにして、エントリー表が一杯になるたびに、おおよそ倍々にインデックス表とエントリー表は拡張されていきます。エントリー表のサイズは、おおよそインデックス表の2/3になるように計算されています。

理論的には、辞書の要素が増えるにつれ、オーバヘッドを除く占有バイト数は次のように変化していきます。

|要素数|エントリー表のバイト数|インデックス表のバイト数|占有バイト数|
|-|-|-|-|
|1~5|24x5=120|1x8=8|128|
|6~10|24x10=240|1x16=16|256|
|11~21|24x21=504|1x32=32|536|
|22~42|24x42=1008|1x64=64|1072|
|43~85|24x85=2040|1x128=128|2168|
|86~170|24x170=4080|2x256=512|4592|
|171~341|24x341=8184|2x512=1024|9208|

以下は、本当に上記のようなことが起きているかを確かめるためのコードです。

```python
import sys
x = dict()
prev_size = 0
curr_size = 0
overhead = sys.getsizeof(x)-128
for i in range(1,2**6+1):
    x.update({i:i})
    curr_size = sys.getsizeof(x)
    if curr_size != prev_size:
        print(i,sys.getsizeof(x)-overhead)
    prev_size = curr_size
```

```python
# 出力
1 128
6 256
11 536
22 1072
43 2168
86 4592
171 9208
342 18416
```

1列目は辞書に加えた要素の数、2列目はオーバーヘッドを除いたメモリの占有バイト数です。

辞書の仕組みが何となく分かっていただけたでしょうか？いずれにせよ、重要なのは、

- 辞書は値オブジェクト（つまり要素）へのアドレスを配列で格納している
- ハッシュ表がキーオブジェクトを配列のインデックスに変換する

ということです。辞書オブジェクトがリストと同じく要素のアドレスしか記憶していないことを把握しておかないと、リストと同じ類のミスを誘発しがちであることに注意しましょう。

## 集合

集合型は、値のないキーだけの辞書と思ってほぼ間違いはありません。集合の要素はキーなので、ハッシュ可能でないといけません。

```python
>>> x = {[3],5}
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unhashable type: 'list'
```

## 文字列

文字列オブジェクトは、リストや辞書と違って、文字へのアドレスではなく文字そのものを格納した配列を内部に持っています。アルファベットはASCIIコードで1文字1バイトを消費します。筆者の環境では文字列オブジェクトのオーバーヘッドは49バイトですので、文字列オブジェクトが消費するメモリは49+文字数バイトになります。

```python
>>> sys.getsizeof("")
49
>>> sys.getsizeof("a")
50
>>> sys.getsizeof("ab")
51
>>> sys.getsizeof("abc")
52
```

ちなみに、日本語のようなユニコード文字列は内部的にUTF-8エンコードで扱われ、オーバーヘッドが74バイト(筆者の環境)、1文字あたり2バイトになるようです。

```python
>>> sys.getsizeof("あ")
76
>>> sys.getsizeof("あい")
78
>>> sys.getsizeof("あいう")
80
>>> sys.getsizeof("あいうa")
82
>>> sys.getsizeof("あいうab")
84
```

文字列オブジェクトは文字そのものを格納しているという事実は、リストや辞書のように、配列内のアドレスを書き換えることによって要素を書き換えることができないことを意味します。換言すれば、文字列を書き換えるためには、メモリ上の文字コードを直接書き換える必要があります。Pythonの標準機能は、このような操作を嫌います。それは、このような操作が、**「箱型の代入」**に相当するからです。Pythonでは、全ての代入を**ラベル型**の代入にすることで言語の振る舞いに一貫性を持たせているようです。そのようなわけで、Pythonでは、文字列はイミュータブルになっているのでしょう。

## 課題

1. 上述の表にあるように、辞書の要素数が86以上のとき、インデックス表の1区画あたりのバイト数は1バイトから2バイトに増量されます。この理由を考えて答えなさい（自分で推測しても良いし、インターネットで検索しても良い）。
