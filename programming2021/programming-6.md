# 第6回 標準ライブラリ

## 標準ライブラリとは

標準ライブラリとは、Pythonをインストールしたときに最初から使うことのできる一連のデータ型、関数、オブジェクトなどを差し、インタープリタに組み込まれているものとモジュールで提供されるものがあります。(ただし、モジュールの中にはビルトインモジュールというインタープリタと切り離せないモジュールもあります。mathやsysがそういった例です。**ビルトイン**は**組込み**を意味します。)実際上は、標準ライブラリといえば、追加のインストール無しで使えることが保証されているものと言った程度の理解で十分です。

今回の講義では、ビルトインデータ型の中でも特に重要な**イテラブル**なデータ型について学んで行きます。その過程で、**文字エンコーディング**、**ハッシュテーブル**、**ファイル入出力**といったプログラミングにおける重要な事項について学んで行きましょう。

## イテラブル

イテラブルなデータ型とは、Python特有の概念で、大雑把にいうと、forループの繰り返し処理においてループインデックスの範囲指定に用いることができるデータ型のことです。つまり

```python
for i in index_range:
  print(i)

```

のようなコードでindex_rangeのところに配置できるものです。(イテラブルのより正確な定義は[iterable](https://docs.python.org/ja/3/glossary.html#term-iterable)を参照。)

組込みデータ型でイテラブルなものには主に次のようなものがあります。

1. コンテナ
   1. シーケンス
      1. リスト(**list**)
      2. タプル(**tuple**)
      3. レンジ(**range**)
   2. 集合(**set**)
   3. 辞書(**dict**)
2. 文字列(**str**)
3. バイト(**bytes**)

これらのデータ型には、ミュータブルなもの・イミュータブルなもの、インデックスやキーによって要素を取得できるもの・できないものといった違いがあります。

|型|mutable|index|key|slice|hashable|`+/*`|制約|
|--|--|--|--|--|--|--|--|
|list|yes|yes|no|yes|no|yes|no|
|tuple|no|yes|no|yes|yes/no|yes|no|
|range|no|yes|no|yes|yes|no|N/A|
|str|no|yes|no|yes|yes|yes|N/A|
|set|yes|no|no|no|no|no|yes|
|dict|yes|no|yes|no|no|no|yes|

なお、上記の表の各列は次のような意味です。

|列名|意味|
|--|--|
|mutable|ミュータブルかどうか|
|index|インデックス参照可能かどうか|
|key|キーで値を取得可能かどうか|
|slice|スライス記法を許すかどうか|
|hashable|ハッシュ可能かどうか|
|`+/*`|`+`、`*`演算子を受け付けるか|
|制約|要素の型に制約があるか|

keyとhashableについては辞書を説明するときに解説します。

リストやレンジについては前回解説しましたので、今回はそれ以外の型(タプル、文字列、辞書、集合)について説明します。バイト型も重要ですが、時間の都合で詳細な解説を割愛します。

## タプル(tuple)

タプルは以下のような性質をもちます。

- イテラブル
- イミュータブル
- インデックス参照可能
- スライス参照可能
- 任意のオブジェクトを要素に持てる
- 算術演算可能

タプルは、リストと同じくシーケンス型に分類されますが、イミュータブルなデータ型です。タプルは、リストをイミュータブルにしたものと考えてほとんど間違いありません。リストと同じく、要素オブジェクトへの参照を格納しています。

リストと同じくインデックス番号やスライスで要素にアクセスでき、どのようなPythonオブジェクトでも要素に持てます。

forループにおける使用方法はリストと同じです。

```python
# 1,2,3と印字
for i in (1,2,3):
    print(i)
```

イミュータブルなので、要素への代入操作は禁止されています。

```python
>>> x = ('foo','bar','baz')
>>> x[0] = 'Python'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
```

タプルの使用において注意しなくてはならないのは、タプルのようなイミュータブルなコンテナ型というのは、要素への参照の変更が禁止されているだけで、参照先の要素オブジェクトの変更は禁止されていないということです。したがって、タプルはイミュータブルですが、次のように要素オブジェクトに変更を加えることは可能です。

```python
>>> x = ('foo','bar',['baz'])
>>> x[2].append('BAZ')
>>> x
('foo', 'bar', ['baz', 'BAZ'])
```

リストと同じくタプルはインデクシングやスライス記法を受け付けます。

```python
>>> x = (1,2,3,4,5)
>>> x[1:4]
(2, 3, 4)
>>> x[3]
4
>>> x[:]
(1, 2, 3, 4, 5)
```

なお、一つしか要素のないタプルを作るためには、次のように、余分なカンマが一つ必要です。

```python
>>> x = (1,)    # 一つしか要素のないタプル
>>> x
(1,)
>>> type(x)
<class 'tuple'>
>>> x = (1)     # これだとただの整数
>>> x
1
>>> type(x)
<class 'int'>
```

なおここで用いたtype関数は引数にあたえたオブジェクトの型を調べるビルトイン関数です。

タプルはリストと同じように+演算子、*演算子を受け付けます。

```python
>>> x = (1,2) + (3,4)
>>> x
(1, 2, 3, 4)
```

```python
>>> x = (1,2) * 3
>>> x
(1, 2, 1, 2, 1, 2)
```

ただし、リストと同じで掛け算はシャローコピーですので、やはり次のような挙動には注意しましょう。

```python
>>> x = ((1,[]),) * 3
>>> x
((1, []), (1, []), (1, []))
>>> x[0][1].append(2)
>>> x
((1, [2]), (1, [2]), (1, [2]))
```

リストと比べたときのタプルの利点としては、それが辞書のキーとして用いることができるということです。これについては辞書の欄で詳しく述べます。

## 文字列(str)

Pythonの文字列型はRと同じくダブルもしくはシングルクォーテーションによって作成でき、以下のような性質を持ちます。

- イテラブル
- イミュータブル
- インデックス参照可能
- スライス参照可能
- 算術演算可能

forループで用いると、一文字ずつループインデックスに渡されます。

```python
# "HELLO WORLD!"を一文字ずつ印字
for c in "HELLO WORLD!":
    print(c,end='--')
print()
```

```python
# 結果
H--E--L--L--O-- --W--O--R--L--D--!--
```

文字列は、インデックスで各文字に、スライスで部分文字列にアクセスできます。イミュータブルなので、変更は一切不可能です。

文字列は+演算子や*演算子を受け付けます。

```python
>>> x = "Hello, " + "World!"
>>> x
'Hello, World!'
>>> print(x)
Hello, World!
>>>
```

```python
>>> x = "knock, " * 10
>>> print(x)
knock, knock, knock, knock, knock, knock, knock, knock, knock, knock,
```

文字列は、イテラブルですが、コンテナ型ではありません。レンジ以外のビルトインのコンテナ型は、要素オブジェクトへの参照を格納していますが、文字列オブジェクトは、文字への参照ではなく文字そのものを格納した配列を内部にもっています。

## エンコーディング

文字をメモリ上に格納する為には、文字をバイト列に変換しなくてはなりません。これを**エンコーディング**と言います。文字をエンコードするには様々な方式があり、そのうち有名なものはutf-8やshift-jisなどがあります。

|文字|shift_jis|euc_jp|utf_8|
|--|--|--|--|
|あ|0x82a0|0xa4a2|0xe38182|
|山|0x8e52|0xbbb3|0xe5b1b1|

文字列が特定のエンコーディングによってどのようなバイト列になるのかは、文字列メソッドのencodeによって確かめることができます。encodeメソッドはバイト型のオブジェクトを返します。

```python
>>> x = 'あ'.encode('shift-jis')
>>> x
b'\x82\xa0'
>>> x.hex()
'82a0'
```

バイト型については解説しませんが、上記のようにhexというメソッドによって、16進数の文字列に変換することができます。

次のコードは、ひらがなの50音をutf-8のコードで書きだすためのPythonコードです。

```python
# %%
a = 'あいうえお'
k = 'かきくけこ'
s = 'さしすせそ'
t = 'たちつてと'
n = 'なにぬねの'
h = 'はひふへほ'
m = 'まみむめも'
y = 'や　ゆ　よ'
w = 'わ　　　を'
n = 'ん　　　　'
x = [a,k,s,t,h,m,y,w,n]
for line in x:
    print(line,end=' --> ')
    for char in line:
        print(char.encode('utf-8').hex(),end=' ')
    print()
```

結果は次のようになります。

```python
あいうえお --> e38182 e38184 e38186 e38188 e3818a 
かきくけこ --> e3818b e3818d e3818f e38191 e38193 
さしすせそ --> e38195 e38197 e38199 e3819b e3819d 
たちつてと --> e3819f e381a1 e381a4 e381a6 e381a8 
はひふへほ --> e381af e381b2 e381b5 e381b8 e381bb 
まみむめも --> e381be e381bf e38280 e38281 e38282 
や　ゆ　よ --> e38284 e38080 e38286 e38080 e38288 
わ　　　を --> e3828f e38080 e38080 e38080 e38292 
ん　　　　 --> e38293 e38080 e38080 e38080 e38080
```

このようにutf-8は全てのひらがなに3バイトを使っています。なお、ここでは、

```python
char.encode('utf-8').hex()
```

のように、encodeメソッドとhexメソッドをつなげています。これは、一つ目のメソッドの戻り値のオブジェクトであるバイトオブジェクトがもつhexメソッドを呼び出していることに相当します。この記法を**メソッドチェーン**と呼び、1つめのメソッドの戻り値には関心がない場合に便利な記法です。

なお、同じエンコーディング方式、同じシンボルでも半角文字と全角文字では異なるバイト列にエンコードされます。プログラミングの初心者にありがちなミスは半角カッコの代わりに全角カッコをつかってしまうことですが、これらがutf-8でどのように異なるのか調べてみましょう。

```python
# %%
'('.encode('utf-8').hex()   # 半角カッコ
'（'.encode('utf-8').hex()  # 全角カッコ
```

```python
# 実行結果
28
efbc88
```

このように、半角カッコは0x28という1バイトであるのに対し、全角カッコは0xefbc88という3バイトの列です。インタープリタはこれらを違う文字として解釈するので、エラーを出します。

たとえば、わざと半角カッコの代わりに全角カッコを使ってタプルを作ってみましょう。

```python
# %%
# 1つめのカッコが全角になっている
x = （5,4,3)
```

```python
# 出力

x = （5,4,3)
  File "<ipython-input-32-7b09692778be>", line 1
    x = （5,4,3)
         ^
SyntaxError: invalid character in identifier
```

## デコーディング

エンコーディングの逆の変換、すなわちバイト列を文字列に変換する操作を**デコーディング**と言います。Pythonでは、バイトオブジェクトのdecodeメソッドを用いて行うことができます。

```python
>>> x_str = 'ありがとう'
>>> thanks_str = 'ありがとう'
>>> thanks_bytes = thanks_str.encode('utf-8')
>>> thanks_bytes
b'\xe3\x81\x82\xe3\x82\x8a\xe3\x81\x8c\xe3\x81\xa8\xe3\x81\x86'
>>> thanks_bytes.hex()
'e38182e3828ae3818ce381a8e38186'
>>> thanks_bytes.decode('utf-8')   # デコーディング
'ありがとう'
```

エンコーディングに用いた方式と異なる方式でテキストをデコードしたときに生じる現象を俗に**文字化け**と呼びます。文字化けはPython上で引き起こすことが可能です。

たとえば6文字の文字列'ありがとう！'(全て全角)はutf-8で18バイトになります。

```python
# %%
x = 'ありがとう！'.encode('utf-8')
print('バイト列 = ',x.hex())
print('バイト数 = ',len(x))
```

```python
# 出力
バイト列 =  e38182e3828ae3818ce381a8e38186efbc81
バイト数 =  18
```

これを1文字2バイトの固定長エンコーディング方式utf-16の9文字としてデコードしてみましょう。

```python
y = x.decode('utf-16')
print('文字列 = ',y)
print('文字数 = ',len(y))
```

```python
# 出力
文字列 =  臣誂臣ꢁ臣膼
文字数 =  9
```

上記ではたまたま'ありがとう！'をutf-8バイト列表現したものがutf-16にデコーディングできましたが、いつもそれが可能であるとは限りません。utf-16では定義されていないバイト列もあるからです。このような場合Pythonはエラーを出してデコードを拒否します。

## 文字列オブジェクトのメモリ占有

文字列オブジェクトのメモリ消費量はどのくらいになるでしょうか？1バイトでは256通りの状態を表すことができることを思い出しましょう。従って、1文字に1バイトを確保すれば、最大256文字を区別することができます。アルファベットと幾つかの記号くらいなら、これで十分です。

しかしながら、ひらがなや漢字が混じると、256文字では足りませんので、最低でも2バイトのメモリが必要です。さらに滅多に使わないような記号まで含めると、2バイトでも足りません。

それぞれのバイト数で表現できる最大文字数は次の通りです。

|バイト数|最大文字数|
|--|--|
|1|`2**8 == 256`|
|2|`2**16 == 65,536`|
|4|`2**32 == 4,294,967,296`|

文字エンコーディングには可変長エンコーディングと固定長エンコーディングがあります。可変長エンコーディングでは文字によってバイト数が異なりますが、固定長エンコーディングでは全ての文字で同じバイト数を使います。実装上の問題で、Pythonの文字列オブジェクトは文字列をメモリ上に記憶するさい、固定長エンコーディングを用いています。

さて、1文字のバイト数を小さくするとメモリ消費量は節約できますが、表現できる文字数は小さくなります。一方、1文字のバイト数を大きくすると、表現できる文字数は多くなりますが、メモリ消費量は大きくなってしまいます。

Pythonはこうしたジレンマを解決するため、文字列の種類によって内部で異なるエンコーディングを使い分けています。アルファベットなどのシンプルな文字列は1バイト文字列で、ひらがなや漢字等が入ったより広い範囲の文字列には2バイトあるいは4バイト文字列を使います。

次のコードは、Python文字列が一文字あたり何バイト使っているかを調べるためのものです。

```python
# アルファベットaの場合
import sys
char = "a"
x = ""
for i in range(10):
    x += char
    print(x,end=" --> ")
    print(sys.getsizeof(x))
```

上のコードで、"x += char"は、"x = x + char"と全く同じ意味で、単なる別表現であることに注意してください。それ以外は、これまで習った知識しか使っていません。

出力は次のようになります。

```python
# 出力。オーバーヘッドは49Byte(環境依存)
a --> 50
aa --> 51
aaa --> 52
aaaa --> 53
aaaaa --> 54
aaaaaa --> 55
aaaaaaa --> 56
aaaaaaaa --> 57
aaaaaaaaa --> 58
aaaaaaaaaa --> 59
```

ひらがなにすると以下のようになります。

```python
# ひらがな「あ」の場合
import sys
char = "あ"
x = ""
for i in range(10):
    x += char
    print(x,end=" --> ")
    print(sys.getsizeof(x))
```

```python
# 出力。オーバーヘッドは74Byte(環境依存)
# ひらがな「あ」の場合
あ --> 76
ああ --> 78
あああ --> 80
ああああ --> 82
あああああ --> 84
ああああああ --> 86
あああああああ --> 88
ああああああああ --> 90
あああああああああ --> 92
ああああああああああ --> 94
```

さらに絵文字の場合です。

```python
# 絵文字の場合
import sys
char = "🐼"
x = ""
for i in range(10):
    x += char
    print(x,end=" --> ")
    print(sys.getsizeof(x))
```

```python
# 出力。オーバーヘッドは76Byte(環境依存)
# 絵文字の場合
🐼 --> 80
🐼🐼 --> 84
🐼🐼🐼 --> 88
🐼🐼🐼🐼 --> 92
🐼🐼🐼🐼🐼 --> 96
🐼🐼🐼🐼🐼🐼 --> 100
🐼🐼🐼🐼🐼🐼🐼 --> 104
🐼🐼🐼🐼🐼🐼🐼🐼 --> 108
🐼🐼🐼🐼🐼🐼🐼🐼🐼 --> 112
🐼🐼🐼🐼🐼🐼🐼🐼🐼🐼 --> 116
```

このように、文字の種類に応じて1、2、4バイト文字を使い分けていることが分かります。

しかしながら、通常プログラマはメモリ容量を気にしているのでない限り、こうしたインタープリタ内部でのエンコーディングを気にする必要はありません。プログラマがエンコーディングを気にしなければならないのは、ファイルの読み書きのときです。プログラマは文字をファイルに保存する際に、エンコーディングを自由に選べます。プログラマがエンコーディングを指定しない場合、Pythonはデフォルトでutf-8を用います。

## ファイル入出力

ここでは、特定のエンコーディングで保存されたテキストファイルを開いて、テキストをPythonの文字列オブジェクトに読み込み、エンコーディングを変えて別のファイルに保存する作業を行ってみましょう。これはPythonの非常に実用的な用途です。

GitHubディレクトリの下に"change_encoding"というフォルダを作って、その中でVS Codeを開いてください。VS Codeを開いたら、change_encodingフォルダの中に"euc_jp.txt"というファイルを新規作成して開いてください。

この状態でVS Codeの画面の右下を見ると、青いバーの上にUTF-8という表示が見られるはずです。

![utf-8](img/utf-8.png)

これは、このファイルが現在UTF-8エンコーディングで開かれていることを意味します。この表示をクリックすると、パレットが開き、

1. エンコード付きで再度開く
2. エンコード付きで保存する

のどちらかを選べるようになりますので、1のエンコード付きで再度開くを選びます。すると、エンコードを選択するパレットに変化しますので、euc-jpと入力してリターンします。すると、右下の表記がEUC-JPに変化します。

![euc-jp](img/euc_jp.png)

これで、現在テキストファイルeuc_jp.txtはeuc_jpエンコードで開かれた状態になりました。この状態で文章を記入して保存すると、euc_jpエンコーディングで保存されることになります。

どのような文章を入力しても良いのですが、ここでは、

```txt
この文章のエンコーディングをeuc_jpからshift_jisに変更します。
```

と入力して保存しましょう。ファイルを保存したら閉じてください。

それでは準備ができたので、いよいよPythonからファイルを開きましょう。VS Code上で、euc_jp.txtと同じフォルダの中に、change_encoding.pyというファイルを作り開いてください。ここに目的のコードを記述して実行しましょう。

テキストファイルを開くには、ビルトイン関数の**open**を使います。openは、**with**命令と共に使うのが普通ですので、セットで覚えましょう。

```python
# %%
with open('./euc_jp.txt','r',encoding='euc_jp') as file:
    text = file.read()
```

この構文では、開かれたファイルは、ファイルオブジェクトとしてfileという変数に代入されます。openの第1引数はファイル名、'r'は「読み込み専用」を意味し、encoding引数はファイルのエンコーディングを表します。ここでは'euc_jp'を指定しています。

ファイルオブジェクトにはファイルを操作するためのメソッド群があり、readメソッドはその内容を読み込んで一つの文字列として返します。上記コードではその戻り値をtextという変数に代入しています。

ファイルオブジェクトは、open関数によって開いたら、使い終わったあとにcloseメソッドによって必ず閉じなければなりません。「どうせ必ず閉じるなら、いつ閉じるかを予め指定して開けばいいのでは？」と思うかもしれません。そのために導入されたのがwith命令です。with命令とともにファイルを開くと、withブロックが終了したときに自動的にファイルがクローズします。withを使うとファイルの閉じ忘れがないので、ファイルを使うときは特に理由がない限りwithで開くようにしましょう。

これで、変数textに読み込まれたファイル内の文章が文字列オブジェクトとして代入されました。ためしに表示してみましょう。

```python
# %%
print(text)
```

```python
# 出力
このファイルのエンコーディングをeuc_jpからshift_jisに変更します。
```

あとはこれをエンコーディングを指定して**別のファイル**に保存するだけです。ファイルへの書き込みは次のようにします。

```python
# %%
with open('./shift_jis.txt','w',encoding='shift_jis') as file:
    file.write(text)
```

読み込みのときとよく似ていますが、openの第1引数は新しいファイルの名前です。ここでは'shift_jis.txt'とします。第2引数の'w'は「書き込み」を意味します。最後にencoding引数は'shift_jis'にしておきましょう。

開いたファイルへ変数textを書き込むには上記のようにwriteメソッドを使います。引数には文字列オブジェクトを与えます。

それでは、VS Codeのファイルエクスプローラを見てみましょう。shift_jis.txtというファイルが新しく出来ているはずなので、開いてみてください。中身は

```txt
このファイルのエンコーディングをeuc_jpからshift_jisに変更します。
```

となっているはずですが、VS Codeの右下のバーを見てみると、表記がShift JISになっているはずです。これはこのファイルがshift_jisでエンコードされていることを表していますので、めでたくエンコーディングの変換ができたことになります。

![shift_jis](img/shift_jis.png)

ここでは、ファイルの中身を一気に読みだして一つの文字列に格納しましたが、行ごとに読み込む方法もあります。教科書のセクション7.2.2に説明がありますので、良く読んでおいてください。

## 辞書(dict)

辞書(ディクショナリとも呼びます)型はRのリストに似たデータ構造で、次の特徴を持ちます。

- イテラブル
- ミュータブル
- 「キーオブジェクト」と「値オブジェクト」のペアを保存する
- ハッシュ可能オブジェクトだけをキーに持てる
- 任意のオブジェクトを値に持てる
- キーを指定して値にアクセスする
- インデックス参照やスライス記法は受け付けない

辞書はPythonにおいて重要であるだけでなく、**ハッシュテーブル**という計算機科学において非常に重要なデータ構造なので、特に詳しく説明します。

リストでは、要素を列挙してリストを作成しました。リストは本質的に**順序集合**です。

```python
>>> x = ['foo','bar','baz']
>>> print(x[1])
bar
```

一方、辞書は要素の順序集合ではなく、オブジェクトのペアの集合です。ペアを構成するオブジェクトは、**キー**および**値**と呼ばれます。

辞書を説明するには、実際の辞書の例が分かりやすいです。

|英単語|意味|
|--|--|
|yep|はい|
|yes|はい|
|yet|しかし|

といった(あまり役に立たない)英和辞書があったとします。この辞書では、英単語から意味を検索できるが、その逆(意味から英単語を検索)はできないとします。

英単語がキー、意味が値に相当します。キーは一意でなくてはなりませんが、値は重複があっても構いません。

実際にこの辞書を作るには次のようにします。

```python
>>> x = {'yep':'はい','yes':'はい','yet':'しかし'}
>>> x
{'yep': 'はい', 'yes': 'はい', 'yet': 'しかし'}
```

ちょうどリストにおいてインデックスから要素を取得したように、キーをしていすれば値を取得できます。

```python
>>> x['yep']
'はい'
>>> x['yet']
'しかし'
```

キーの一覧、値の一覧、キーと値のペアの一覧を取得するには、keysメソッド、valuesメソッド、itemsメソッドを使います。

```python
>>> x.keys()
dict_keys(['yep', 'yes', 'yet'])
>>> x.values()
dict_values(['はい', 'はい', 'しかし'])
>>> x.items()
dict_items([('yep', 'はい'), ('yes', 'はい'), ('yet', 'しかし')])
```

新しいPythonでは、上記のようにキーの一覧、値の一覧、ペアの一覧はdict_keys、dict_values、dict_itemsという特殊なイテラブルデータ型で返されます。これは、適宜リストや集合、タプルに変換して用いることができます。

たとえばリストに変換するには、関数listを使います。

```python
>>> y = list(x.keys())
>>> y
['yep', 'yes', 'yet']
>>> z = list(x.values())
>>> z
['はい', 'はい', 'しかし']
>>> a = list(x.items())
>>> a
[('yep', 'はい'), ('yes', 'はい'), ('yet', 'しかし')]
```

## ループでの挙動

辞書をリストの代わりにループインデックスの範囲として指定すると、ループインデックスにはキーだけが代入されます。つまり、次の2つのコードは全く同じ意味です。

```python
# %%
for i in x.keys():
    print(i)
# %%
for i in x:
    print(i)
```

キーと値の両方を使いたいときは、次のようにしなくてはなりません。

```python
# %%
for i,j in x.items():
    print(i,"-->",j)
```

```python
# 出力

yes --> はい
yep --> はい
yet --> しかし
```

ここでx.items()から、(i,j)への**アンパック代入**が行われていることに注意してください。

## ハッシュ可能オブジェクト

任意のオブジェクトが値になれますが、キーに指定できるのは、**ハッシュ可能な**Pythonオブジェクトのみです。

あるアルゴリズムによってオブジェクトを数字に変換することをハッシュ化と呼びます。ハッシュ化によって得られる数値をハッシュ値と呼び、当のアルゴリズムをハッシュ関数と呼びます。全てのPythonオブジェクトがハッシュ化できるわけではなく、ハッシュ化できるオブジェクトをハッシュ可能(hashable)であると言います。

リストや集合といったミュータブルなビルトインオブジェクトはハッシュ可能ではありません。数値や文字列などイミュータブルなビルトインオブジェクトはほとんど全てハッシュ可能ですが、例外はあります。

```python
>>> x = {}
>>> x[(1,2,3)]=123
```

```python
>>> x = {}
>>> x[(1,2,[3])]=123
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unhashable type: 'list'
```

一つ目の例ではタプルをキーに指定していますが、全く問題ありません。一方二つ目の例でもタプルをキーにしていますが、このタプルは[3]というハッシュ不可能な要素(リスト)を持っているため、ハッシュ可能ではありません。タプルがハッシュ可能であるためには、そのすべての要素がハッシュ可能である必要があります。

## ハッシュ表

それでは、次のコードを例に、辞書を作成する際に何が起きているのかを見ていきましょう。

```python
>>> x = {'foo':123,'bar':456,'baz':789}
```

上のコードを実行すると、Pythonは232バイトのメモリ領域を確保します（具体的なバイト数は処理系やPythonのヴァージョンに依存します）。

```python
>>> import sys
>>> sys.getsizeof(x)
232
```

この232バイトのうち、104バイトは参照カウンタなどを含むオーバーヘッドで、本質的なのは残り128バイトです。この128バイトは、**ハッシュ表(ハッシュテーブル)**というデータ構造を格納しています。ハッシュ表の役割は、キーオブジェクトを、要素オブジェクト（キーに対して**値**ともいいます）に対応付けることです。

最近のバージョンのPythonでは、ハッシュ表はインデックス表とエントリー表という二つの部分から構成されています(本講義では仮にそのように呼ぶことにします)。インデックス表は、1区画1バイトからなる8区画の一続きのメモリ領域で、合計8バイトを占有しています。一方エントリー表は、1区画24バイトからなる5区画の一続きのメモリ領域で、合計120バイトを占有しています。

次に、Pythonは第一のキーオブジェクト'foo'をハッシュ化します。

```python
>>> hash("foo")
531872228806607122
>>> hash("foo") & 0b111
2
```

上のコードでは、hash関数で'foo'をハッシュ化し、下3ビットを取り出しています。Pythonは、キーオブジェクト'foo'（のアドレス）、値オブジェクト123（のアドレス）、そしてキーのハッシュ値（上記の値）をセットにしてエントリー表の第0番目に記録します。キー・値・ハッシュ値がそれぞれ8バイトずつ占有するので、合計8×3=24バイトで1区画を占有します。

次に、ハッシュ値の下3桁をみると、0b010=2ですので、Pythonは、インデックス表の2番目の区画に、0を記録します。これにより、キー'foo'に対応する情報は、エントリー表の0番目の区画に記録されているということが分かるようになります。同じことを、'bar'と'baz'に対しても行うと、図のようなインデックス表とエントリー表ができあがります(ハッシュ化により'bar'は0b110=6、'baz'は0b001=1を割り当てられる）。

```python
>>> hash("bar")
-1001163682187755818
>>> hash("bar") & 0b111
6
>>> hash("baz")
2724165034148455057
>>> hash("baz") & 0b111
1
```

さて、次のようなコードを実行したとしましょう。

```python
# xは定義済み
>>> print(x['baz'])
789
```

このとき、Pythonは、まずキーオブジェクト'baz'をハッシュ化して、その2進数表記の下3桁をとりだします。すると0b001=1という値でしたので、インデックステーブルの1番目の要素を探します。すると、2という値が記録してあるので、エントリーテーブルの2番目の要素をチェックし、そこに'baz'と789が登録されていることを確認します。このようにして、値789を取り出し、print関数で印字しているということになります。

なお、ハッシュ化して下3桁をとると、複数のキーが同じインデックスになってしまうことがあります。これを**ハッシュ衝突**と呼びます。二つのキーでハッシュ衝突が起きると、後からやってきたキーは適当なアルゴリズムで別のインデックスを振られます（このアルゴリズムに興味がある人は、自分で調べてみましょう）。

インデックス表が埋まってくると、だんだんと衝突の確率が上がってきます。衝突が多いほど、登録にも検索にも時間がかかるようになります。ですので、衝突を最小限に抑えるために、インデックス表の区画数はエントリー表よりもすこし大きめに確保してあります。エントリー表が満杯になると、インデックス表とエントリー表が両方とも拡張されます。このとき、エントリー表のサイズは10区画、インデックス表のサイズは16区画に拡張されます。再びエントリー表が一杯になると、再度拡張がおき、今度はエントリー表は21区画、インデックス表は32区画になります。このようにして、エントリー表が一杯になるたびに、おおよそ倍々にインデックス表とエントリー表は拡張されていきます。エントリー表のサイズは、おおよそインデックス表の2/3になるように計算されています。

理論的には、辞書の要素が増えるにつれ、オーバヘッドを除く占有バイト数は次のように変化していきます。

|要素数|エントリー表のバイト数|インデックス表のバイト数|占有バイト数|
|-|-|-|-|
|1~5|24x5=120|1x8=8|128|
|6~10|24x10=240|1x16=16|256|
|11~21|24x21=504|1x32=32|536|
|22~42|24x42=1008|1x64=64|1072|
|43~85|24x85=2040|1x128=128|2168|
|86~170|24x170=4080|2x256=512|4592|
|171~341|24x341=8184|2x512=1024|9208|

以下は、本当に上記のようなことが起きているかを確かめるためのコードです。

```python
import sys
x = dict()
prev_size = 0
curr_size = 0
overhead = sys.getsizeof(x)-128
for i in range(1,2**6+1):
    x.update({i:i})
    curr_size = sys.getsizeof(x)
    if curr_size != prev_size:
        print(i,sys.getsizeof(x)-overhead)
    prev_size = curr_size
```

```python
# 出力
1 128
6 256
11 536
22 1072
43 2168
86 4592
171 9208
342 18416
```

1列目は辞書に加えた要素の数、2列目はオーバーヘッドを除いたメモリの占有バイト数です。

辞書の仕組みが何となく分かっていただけたでしょうか？いずれにせよ、重要なのは、

- 辞書は値オブジェクト（つまり要素）へのアドレスを配列で格納している
- ハッシュ表がキーオブジェクトを配列のインデックスに変換する

ということです。辞書オブジェクトがリストと同じく要素のアドレスしか記憶していないことを把握しておかないと、リストと同じ類のミスを誘発しがちであることに注意しましょう。

## 集合

集合型は、内部構造をもたないオブジェクトの集まりです。集合は、値のないキーだけの辞書と思ってほぼ間違いはありません。以下のような特徴を持ちます。

- イテラブル
- ミュータブル
- インデックス・スライス参照不可
- キー参照不可
- ハッシュ可能オブジェクトだけを要素に持てる
- 算術演算不可

集合の要素は辞書のキーに相当するため、ハッシュ可能でないといけません。

```python
>>> x = {[3],5}
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unhashable type: 'list'
```

## 課題

1. 上述の表にあるように、辞書の要素数が86以上のとき、インデックス表の1区画あたりのバイト数は1バイトから2バイトに増量されます。この理由を考えて答えなさい（自分で推測しても良いし、インターネットで検索しても良い）。
