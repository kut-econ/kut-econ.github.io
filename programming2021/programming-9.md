# 第9回 NumPy/SciPy入門

## NumPy/SciPyとは

これまで見てきたように、Pythonには、Rのベクトルのような数値計算に適したデータ型が標準で備わっていません。それはPythonが**汎用プログラミング言語**だからです。Pythonは、一つの仕事に特化した機能を標準で提供するのではなく、標準機能は柔軟性が高く、汎用性の高いものだけを提供し、専門的な機能については、全てモジュールあるいはパッケージの形で、拡張機能として提供する仕組みを採用しています。そのおかげで、世界中の有志のプログラマによって、Pythonの様々な拡張機能が提供され、機械学習、ウェブアプリケーション、GIS、経済実験など、多様な分野で成功を収めて来ました。

今回取り上げる**NumPy**はPythonに高度な数値計算ライブラリを提供するモジュールで、他の様々なライブラリがNumPyに依存しています。Pythonでデータ解析をするならば、NumPyは絶対に避けて通れませんので、今回の講義でしっかりと基礎を押さえましょう。

また、NumPyをベースにした科学計算ライブラリである**SciPy**についても簡単に取り上げます。NumPyの機能は非常に高度で強力ですが、科学の個別の分野には適応していません。統計や物理計算などの個別の分野に特化した計算は、NumPyをベースにした**SciPy**モジュールが提供します。

なお、NumPyやSciPyのような複数のモジュールを集めて作ったモジュールは**パッケージ**と呼ばれます。[リファレンスマニュアル](https://docs.python.org/3/reference/import.html#packages)にあるように、全てのパッケージはモジュールですが、モジュールは必ずしもパッケージではありません。

使う側からすると、あるモジュールがパッケージかどうかということは通常問題になりません。従って、本講義では、区別する必要が生じないかぎり、パッケージのことをモジュールと呼ぶことにします。

## NumPyの利点

NumPyを使う利点は、主に以下のようなものでしょう。

- ベクトルや高次元の配列を扱うことができる
- 種々のベクトル・行列演算が可能
- 標準機能に比べ、演算が高速

中でも**速度**の問題は科学技術計算において重大です。特にPythonのforループによる処理が遅いことはPythonユーザーの間でも有名です。常識的な時間内に、本格的な科学計算を終わらせたいのなら、Pythonのリストやforループ、内包表記と言ったものをコードの主要な部分で使おうとは考えないことです。

NumPyでのベクトル演算が高速な主な理由は、C言語でのプログラミングと同じように、メモリ上で連続した配列(各要素のバイト数は固定)に直接数値を格納し、しかも一つの配列には「整数」や「浮動小数点数」など決まったデータ型の数値しか格納しないからです。

一方、これまで学んできたように、リストを始め、Pythonのコンテナは全て数値そのものではなく、オブジェクトへの参照を格納しています。しかも、オブジェクトのデータ型は、実際にオブジェクトが参照されるまでわかりません。

より具体的にPythonが遅い理由を考えるため、「リストAの要素とリストBの要素を要素ごとに足して、一つのリストを作る」という操作をPythonが処理するときの手順について考えてみるとよいでしょう。第1要素を足し合わせるだけで、以下のプロセスが必要になります。

1. リストA、Bの第1要素に格納されている参照(アドレス)を取得
2. それらの参照をたどって、2つのオブジェクトを取得
3. 2つのオブジェクトの型を調べる
4. `+`演算子が2つの型の間で定義されているか調べる
5. 定義されていなければエラーを返す
6. 定義されていれば2つのオブジェクトから数値を取り出して足す
7. 演算結果の数値をPythonの数値オブジェクトに加工する

少なくともこれだけの操作が、**それぞれの要素**について必要になるはずです。

一方NumPyのベクトルの場合は、一つのベクトルが複数のデータ型を混在させることはありません。従って要素ごとに演算がどのように定義されているか調べる必要はありません。しかもベクトルは参照ではなく数値そのものを格納しているため、参照をたどる時間も必要ありませんし、計算結果を要素ごとにオブジェクト化する時間も必要ありません。これが主な高速化の理由ですが、他にも内部で諸々の効率性のよいアルゴリズムを使っているということがあるでしょう。

実行速度など、コードのパフォーマンスを評価する作業のことを**プロファイリング**と呼びます。あとで簡単なプロファイリングのやり方を解説しますが、そのときに、forループでの作業に比べてNumPyのベクトル演算がどれだけ高速であるか評価することにしましょう。

## 目標

NumPyやSciPyの様々な機能を1回の講義で幅広く説明することは困難です。そこで、今回は的を絞り、以下の2点の達成を目標とします。

- NumPyで線形モデルに従って疑似データを作成する
- そのデータに対してSciPyで線形回帰を行う

上記の作業を自分でできるようになれば、NumPy/SciPyのマニュアルはインターネット上や書籍で豊富に提供されていますので、他の作業は容易に独学で学ぶことができると思います。

独学の際に有用な資料を以下にリストアップしておきます。

- [NumPyリファレンス](https://numpy.org/doc/stable/reference/)
- [SciPyリファレンス](https://docs.scipy.org/doc/scipy/reference/)
- [NumPyによるデータ分析入門](https://www.amazon.co.jp/NumPy%E3%81%AB%E3%82%88%E3%82%8B%E3%83%87%E3%83%BC%E3%82%BF%E5%88%86%E6%9E%90%E5%85%A5%E9%96%80-%E2%80%95%E9%85%8D%E5%88%97%E6%93%8D%E4%BD%9C%E3%80%81%E7%B7%9A%E5%BD%A2%E4%BB%A3%E6%95%B0%E3%80%81%E6%A9%9F%E6%A2%B0%E5%AD%A6%E7%BF%92%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AEPython%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0-Umit-Mert-Cakmak/dp/4873118875)

## 配列作成

それでは、早速NumPyを使ってみましょう。まず準備として、Anacondaの`base`以外の環境を使っている方は、`numpy`モジュールをインストールする必要があります。

```cmd
conda install numpy
```

NumPyのモジュール名は`numpy`です。ルールではありませんが、`numpy`は`np`という別名で`import`するのが慣習ですので、特に理由がないかぎりそうしましょう。

したがって、次のように`import`してください。以降、`numpy`は`np`の名前で使うことができるようになります。

```python
import numpy as np
```

NumPyの主要なデータ型は`ndarray`という配列型です。NumPyは、配列オブジェクトを作成し、配列オブジェクトを操作するためのモジュールであると考えて概ね間違いはありません。よって、配列を極めることがNumPyを極めることでもあります。

### 配列様オブジェクトから作成

配列を作る方法は色々とありますが、最も基本的なのは、**配列様**オブジェクトから作成する方法です。配列様(array-like)とは、[リファレンス](https://numpy.org/doc/stable/glossary.html#term-array-like)で説明されているように、配列として解釈可能なオブジェクトであり、リスト、タプル、レンジなどの形式をとります。ここではレンジを用いて配列を作成してみます。

```python
>>> x = np.array(range(10))
>>> x
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> type(x)
<class 'numpy.ndarray'>
```

このように、配列を出力すると、`array([...])`という表記で出力されますが、内側の`[]`はPythonのリストとは何の関係もありません。上記の配列`x`では、0から9までの数値が、連続した80バイトのメモリ領域に格納されています。

`x`のデータ型は`ndarray`ですが、`x`が内部にもっている数値データの配列もまた『型』を持ちます。データの型は、`ndarray`オブジェクトの`dtype`属性に収められています。

```python
>>> x.dtype
dtype('int64')
```

この出力は、`x`内部の要素配列が`int64`というNumPyモジュール内で定義されたデータ型を有することを示しています。

`int64`型の数値は、64ビット、つまり8バイトのメモリ領域に格納される整数です。8バイト整数は仮に非負の整数だけに用いれば`0〜2**64-1`の範囲の整数を表すことができますが、`int64`は符号つき整数ですので、`-2**32〜2**32-1`、つまり下が`-4294967296`から上が`4294967295`までの整数を表現することができます。

一つの数値で8バイト占有しますので、`x`の配列全体では80バイト消費しているはずですが、これを確認することができます。`ndarray`型オブジェクトは、属性`nbytes`にオーバーヘッドを除いた占有メモリ量を格納しています。

```python
>>> x.nbytes
80
>>> import sys
>>> sys.getsizeof(x)
184
```

上記のように、筆者の環境では`x`全体が184バイト占有していますのでオーバーヘッドは104バイトということになります(オーバーヘッドはNumPyのバージョンや環境に依存しえます)。

`ndarray`オブジェクト内部の数値型は、配列オブジェクトを作成するときに適当なものが自動的に選択されます。上記で数値型が自動的に`int64`になったのは、筆者の環境が64ビット処理系であることに関連しています。

数値型を明示的に指定したい場合は、`array`関数の`dtype`引数に数値型を指定します。たとえば、小さな正整数しか扱わないことが分かっている場合は、メモリを節約するために、数値型を符号なし16ビット整数に設定したいということがあるかもしれません。その場合は、`array`関数の`dtype`引数に数値型を指定します。

```python
>>> x = np.array(range(10),dtype=np.uint16)
>>> x
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], dtype=uint16)
>>> x.nbytes
20
```

これで使用メモリの`3/4`を節約することができました(ただしオーバーヘッド除く)。ここで`uint16`は"unsigned integer 16 bits"(符号なし16ビット整数)を表すデータ型であり、NumPyモジュール内で`uint16`という名前で定義されています。

NumPyには、主に以下のような数値型があります。

|数値型|意味|
|--|--|
|`int8`|8ビット符号付き整数|
|`int16`|16ビット符号付き整数|
|`int32`|32ビット符号付き整数|
|`int64`|64ビット符号付き整数|
|`uint8`|8ビット符号なし整数|
|`uint16`|16ビット符号なし整数|
|`uint32`|32ビット符号なし整数|
|`uint64`|64ビット符号なし整数|
|`float16`|16ビット浮動小数点数|
|`float32`|32ビット浮動小数点数|
|`float64`|浮動小数点数(通常64ビット、処理系依存)|
|`complex64`|64ビット複素数|
|`complex128`|複素数(通常128ビット、処理系依存)|

## インデクシング

NumPyの配列は、Pythonのリストと同じように、インデックス参照およびスライス記法を受け付けます。

## ブロードキャスト

## ベクトル演算

### 多次元配列

関数`array`の引数に入れ子のリストを与えると、多次元の配列を作ることができます。

```python
>>> x = np.array([[1,2,3],[4,5,6]])
>>> x
array([[1, 2, 3],
       [4, 5, 6]])
```

上では、2次元の配列を作成しました。上の配列は、2行3列の行列として解釈することもできることに注意してください。そのため、2次元の配列をことを、**行列**と呼ぶことがあります。

### 特殊な初期値の配列

たとえば、0を10個格納した配列

## SciPyとは

## 参考書

