# 第4回 変数とメモリ

- [第4回 変数とメモリ](#第4回-変数とメモリ)
  - [Rの付値操作](#rの付値操作)
  - [箱型代入](#箱型代入)
  - [ラベル型代入](#ラベル型代入)
  - [Copy on modifyメカニズム](#copy-on-modifyメカニズム)

## Rの付値操作

本講義の受講者にとって、Rの次のような操作は至極ありふれたものだと思います。

```R
# コード1
x <- c(1,2,3)
y <- x
x[2] <- 5
print(x)
print(y)
```

上記のコマンドを実行したときに、どのような結果が出力されるかを答えられない人はいないでしょう。実際にRの対話的インタープリタを起動するか、VS Code上で実行してみれば良いでしょう。

```R
> print(x)
[1] 1 5 3
> print(y)
[1] 1 2 3
> 
```

しかし、コード1で実際に何が起きているのかを正しく説明できる人はほとんどいないのではないかと思います（できたら素晴らしい！）。

多くの人が次のように考えているのではないでしょうか？

1. 変数xにベクトル(1,2,3)が代入される
2. 変数yに変数xの値、つまり(1,2,3)がコピーされる
3. 変数xの第2要素が5に書き換えられる
4. 変数xの値が出力される
5. 変数yの値が出力される

しかし、実際には、**上記のようなことは起きていません**。これを今日は理解して欲しいと思います。これを理解できるかどうかが、Pythonを理解する鍵であり、もっというなら、Pythonを含む様々な**動的型付け言語**を理解する鍵となります。

## 箱型代入

どのように間違っているかを説明する前に、なぜ上記のような間違いを犯しがちであるのかを説明しましょう。間違いの理由は、初学者向けにありがちな、「箱の比喩」を用いた代入の説明にあるものと思われます。

箱を用いた説明とは、次のようなものです。

>下図のように、変数xに1を代入するということは、xという箱に1という値を入れることであり、yにxを代入するということは、xに入っている値1をコピーしてyという箱に入れることである。

![box-type substitution](img/box_explanation.drawio.png)

このような説明は、C言語のようなプログラミング言語では正しい比喩ですが、RやPythonではミスリーディングです。Pythonでは特にミスリーディングであるだけでなく完全に間違いであり、害悪ですらあります。

C言語では、次のようにして、予めxやyが整数であることをプログラムの最初に宣言します。

```C
int x,y; // x,yが整数であることを宣言
```

ソースファイルにこの宣言を見つけたCのコンパイラは、メモリの特定の位置に整数用の場所を2か所確保し、それらにxとyという名前をつけます。xやyが最初に割り当てられた場所以外を指し示すことは基本的に無く、「うごかない箱」であると見なすことができます。

```C
y = x;  // xの値をyに代入
```

という代入操作は、xの箱（メモリの特定領域）に入っている値をyの箱にコピーするという操作に他なりません。

## ラベル型代入

一方、Rでは何が起きているのでしょうか。正しい比喩は以下のようなものです。

>下図のように、変数xに1を代入するということは、1という**モノ**([**オブジェクト**](https://ja.wikipedia.org/wiki/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88_(%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0)))にxというラベルを貼り付けることであり、変数yにxを代入するという操作は、ラベルxがついているオブジェクトにもう一つyという別のラベルを貼り付けることである。

![label-type substitution](img/label_explanation.drawio.png)

この正しい見方では、1という一つのオブジェクトにx、yという二つのラベルが貼り付けられています。

それでは、Rでの代入操作(y <- x)がこのような「ラベル張り」であるということを確かめてみましょう。そのために、[Hadley Wickham](http://hadley.nz/)が作った[pryr](https://cran.r-project.org/web/packages/pryr/index.html)パッケージをインストールしましょう。

```R
install.packages('pryr')
```

pryrを読み込むと関数addressを使うことができるようになります。addressは、引数として与えた変数が指し示しているオブジェクトのアドレスを返す関数です…と言っても良く分からないかもしれないので、実際に使ってみましょう。

```R
library(pryr)
x <- c(1,2,3)
address(x)
y <- x
address(y)
```

上のように対話的インタープリタで入力すると、次のような出力が得られます。

```R
> address(x)
[1] "0x183f3110"
> y <- x
> address(y)
[1] "0x183f3110"
> 
```

出力が二つ得られていますが、一つ目の値**0x183f3110**は、xというラベルが貼り付けられているベクトル(1,2,3)というオブジェクトが格納されているメモリのアドレスを16進数で表したものです（具体的なアドレスの値は、実行時ごとに異なります）。また、二つ目の出力は、yというラベルが貼り付けられているオブジェクトのメモリ上のアドレスですが、これも**0x183f3110**となっており、xと同じオブジェクトにyが貼り付けられているということが分かります。

もしもC言語のように、x、yという別々の箱がメモリ上に存在するならば、上記の出力は説明がつきませんよね。

このように、Rでの代入は「ラベル張り」であり、「箱入れ」ではないことが分かります。その意味でRでは代入のことを**付値**と呼びますが、これは名が体を表す正しい呼び名であり、推奨される言葉遣いです。それから、Rでは、付値を表す記号として、わざわざ二文字の「<-」という記号を使いますが、これも素晴らしい計らいであると言えます。代入に「=」記号を使うと、ついつい自分は箱への代入をしていると思ってしまいがちですが、二文字の「<-」記号が生み出す左辺と右辺の微妙な距離感は、自分が「箱入れ」ではなく「ラベル張り」をしているということを思い出させてくれます。

## Copy on modifyメカニズム

ところが、RはCopy on modifyという機構を備えていて、ラベル張りであることを余り意識させない作りになっています。