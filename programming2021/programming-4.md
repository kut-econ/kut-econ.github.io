# 第4回 変数とメモリ

- [第4回 変数とメモリ](#第4回-変数とメモリ)
  - [Rの付値操作](#rの付値操作)
  - [ハコ型代入](#ハコ型代入)
  - [ラベル型代入](#ラベル型代入)
  - [参照カウンタ](#参照カウンタ)
  - [コピー遅延](#コピー遅延)
    - [練習](#練習)
  - [Pythonの挙動](#pythonの挙動)
  - [変更と代入の違い](#変更と代入の違い)
  - [宿題(ホームワーク)](#宿題ホームワーク)

## Rの付値操作

本講義の受講者にとって、Rの次のような操作は至極ありふれたものだと思います。

```R
# コード1
x <- c(1,2,3)
y <- x
x[2] <- 5
print(x)
print(y)
```

上記のコマンドを実行したときに、どのような結果が出力されるかを答えられない人はいないでしょう。実際にRの対話的インタープリタを起動するか、VS Code上で実行してみれば良いでしょう。

```R
> print(x)
[1] 1 5 3
> print(y)
[1] 1 2 3
> 
```

しかし、コード1で実際に何が起きているのかを正しく説明できる人はあまり多くないと思います。多くの人が次のように考えているのではないでしょうか？

1. 変数xにベクトル(1,2,3)が代入される
2. 変数yに変数xの値、つまり(1,2,3)がコピーされる
3. 変数xの第2要素が5に書き換えられる
4. 変数xの値が出力される
5. 変数yの値が出力される

しかし、実際に起きていることは、上記と少し違います。これを今日は理解して欲しいと思います。

## ハコ型代入

どのように間違っているかを説明する前に、初学者向けの書籍に良く見られる「箱の比喩」を用いた代入の説明について解説しておきます。

箱を用いた説明とは、次のようなものです。

>下図のように、変数xに1を代入するということは、xという箱に1という値を入れることであり、yにxを代入するということは、xに入っている値1をコピーしてyという箱に入れることである。

![box-type substitution](img/box_explanation.drawio.png)

このような説明は、C言語のようなプログラミング言語では正しい比喩ですが、RやPythonでは正しくありません。特にPythonでは正しい理解を妨げる説明です。

C言語では、次のようにして、予めxやyが整数であることを変数の作成時に宣言します

```C
int x,y; // x,yが整数であることを宣言
```

ソースファイルにこの宣言を見つけたCのコンパイラは、マシン語に変換する際に、xやyといった変数名をメモリのアドレス(実際にはメモリ領域)あるいはレジスタ名といったもので置き換えてしまいます。

したがって、

```C
y = x;  // xの値をyに代入
```

という代入操作は、あるアドレスのメモリ領域に格納されている値を別のメモリ領域にコピーすることを意味します。したがって、メモリ領域を箱と考えれば、箱の比喩は正しく実際に起こっていることを表しています。

## ラベル型代入

プログラミングの世界では、124や"c"のような具体的な数値や文字だけではなく、それを操作するための付属的な情報を合わせもつものを**オブジェクト**と呼びます。オブジェクトは、一見ただの数値や文字に見えても、数値や文字を格納する領域以外にもメモリ領域を占有しています。C言語の整数や文字列は、値を格納する分だけのメモリ領域しか占有しないので、オブジェクトではありません。一方、PythonやRの数値や文字列はすべてオブジェクトです。

RやPythonでの代入の説明でより現実に近いのは以下のような比喩です。

>下図のように、変数xに1を代入するということは、1という[**オブジェクト**](https://ja.wikipedia.org/wiki/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88_(%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0))にxというラベルを貼り付けることであり、変数yにxを代入するという操作は、ラベルxがついているオブジェクトにもう一つyという別のラベルを貼り付けることである。

![label-type substitution](img/label_explanation.drawio.png)

この正しい見方では、1という一つのオブジェクトにx、yという二つのラベルが貼り付けられています。このようなラベルのことを**参照**(reference)と呼びます。RやPythonでは変数=参照です。

それでは、Rでの代入操作(y <- x)がこのような「ラベル張り」であるということを確かめてみましょう。そのために、[Hadley Wickham](http://hadley.nz/)が作った[pryr](https://cran.r-project.org/web/packages/pryr/index.html)パッケージをインストールしましょう。

```R
install.packages('pryr')
```

pryrを読み込むと関数addressを使うことができるようになります。addressは、引数として与えた変数(参照)が指し示しているオブジェクトのアドレスを返す関数です。実際に使ってみましょう。

```R
library(pryr)
x <- c(1,2,3)
address(x)
y <- x
address(y)
```

上のように対話的インタープリタで入力すると、次のような出力が得られます。

```R
> address(x)
[1] "0x183f3110"
> y <- x
> address(y)
[1] "0x183f3110"
> 
```

出力が二つ得られていますが、一つ目の値**0x183f3110**は、xというラベルが貼り付けられているベクトル(1,2,3)というオブジェクトが格納されているメモリのアドレスを16進数で表したものです（具体的なアドレスの値は、実行時ごとに異なります）。また、二つ目の出力は、yというラベルが貼り付けられているオブジェクトのメモリ上のアドレスですが、これも**0x183f3110**となっており、xと同じオブジェクトにyが貼り付けられているということが分かります。

このように、C言語とは違ってx、yという別個のメモリアドレスが存在するわけではないことが分かります。

## 参照カウンタ

ところが、Rは**Copy on modify**という機構を備えていて、ラベル張りであることを余り意識させない作りになっています。Copy on modify機構について説明するために、まずは**参照カウンタ**(リファレンスカウンタ）について説明しましょう。以下、Rのヴァージョン3系列(3.5,3.6等)を仮定して話を進めます。(ヴァージョン4との違いは課題で取り扱います。)

ベクトルのようなRのオブジェクトは、自分に何枚のラベルがついているかに関する情報を内部に格納しています。換言すると、Rオブジェクトは、自分がいくつの変数(xやy)に**参照されているか**を知っています。オブジェクトを参照している変数の数の事を**参照カウント**と呼びます。Rオブジェクトは、内部に自分自身の参照カウントを記憶する**参照カウンタ**を持っています。

参照カウンタの値は、関数pryr::refsによって調べることができます。

```R
> rm(list=ls()) #一応全変数を削除
> x <- c(1,2,3)
> refs(x)
[1] 1
> y <- x
> refs(x)
[1] 2
> refs(y)
[1] 2
> 
```

## コピー遅延

さて、次のようにxに代入したベクトル(1,2,3)の内容を書き換えようとするとき、参照カウントが1の場合と2以上の場合では、Rは異なる挙動を示します。

まずxの参照カウントが1の場合です。

```R
rm(list=ls()) #全変数を削除
x <- c(1,2,3)
address(x)
x[2] <- 5
address(x)
```

上記を実行すると、次のような出力が得られます。

```R
> x <- c(1,2,3)
> address(x)
[1] "0x17f14dd8"
> x[2] <- 5
> address(x)
[1] "0x17f14dd8" #xのアドレスは変わらない
> 
```

上記のように、xの内容を書き換える前後で、xは同じオブジェクトを参照しています。

ところが、xの参照カウントが2以上のとき、つまりxと同じオブジェクトを参照する変数yが存在するとき、異なる挙動が起きます。次を実行してみましょう。

```R
rm(list=ls()) #全変数を削除
x <- c(1,2,3)
y <- x
address(x)
address(y)
x[2] <- 5
address(x)
address(y)
```

上記を実行すると、次のような出力が得られます。

```R
> rm(list=ls()) #全変数を削除
> x <- c(1,2,3)
> y <- x
> address(x)
[1] "0x17ecbc78"
> address(y)
[1] "0x17ecbc78"
> x[2] <- 5
> address(x)
[1] "0x17ecb598"  #xのアドレスが変わった!
> address(y)
[1] "0x17ecbc78"
> 
```

上記のように、参照カウントが2以上になると、オブジェクトの内容を変更する際に、あらたなメモリ領域が確保され、オブジェクトがコピーされてから変更が行われることが分かります。このメカニズムを**Copy on modify**と呼びます。Copy on modifyとは、「変更があるまでコピーはしない」という意味合いで、**コピー遅延**とも呼ばれます。

Copy on modify機構のおかげで、Rのプログラマは、オブジェクトがいくつの変数に参照されているかをあまり意識する必要がありません。xの内容を修正したときに、うっかりyの内容まで修正してしまう危険がないわけです。

![copy_on_modify](img/copy_on_modify.drawio.png)

### 練習

1. 次のRコードは、二つの参照を持つリストオブジェクトの内容を変更するものである。pryr::address関数を用いて、上記のコードでCopy on modify機構が働いているかどうか確かめなさい。

    ```R
    rm(list=ls()) # 全変数を削除
    x <- list(a='A',b='B')
    y <- x
    x['a'] <- 'AA'
    ```

2. 次はさらに複雑な例である。

## Pythonの挙動

ところが、PythonにはCopy on modify機構がありません。どういうことかというと、オブジェクトがいくつの変数に参照されているかにかからわず、オブジェクトの内容変更に伴うコピーは自動的には起きません。

これを実際に確かめてみましょう。
Pythonにはベクトル型は存在しないので、代わりにリストを使いましょう。たとえば1,2,3という三つの整数を要素にもつリストは次のように作成します。(リストについては、次回詳しく取り上げます。)

```python
>>> x = [1,2,3]
>>> x
[1, 2, 3]
```

Rのベクトルでは最初の要素にアクセスするにはx[1]と書きますが、pythonのリストではx[0]と書きます。つまり、インデックスは0からはじまります。それを除けばインデクシングのルールはRのベクトルと非常によく似ています。

```python
>>> x
[1, 2, 3]
>>> x[0]
1
>>> x[1]
2
>>> x[2]
3
```

さてそれでは準備が出来たので実験を開始しましょう。
PythonにおけるRのpryr::addressに対応する関数はビルトイン関数のidです。idは、変数が参照するオブジェクトのアドレスを10進数で返します。まずはpythonの変数が参照であることを確認しましょう。

```python
>>> x = [1,2,3]
>>> y = x
>>> id(x)
2080340453760
>>> id(y)
2080340453760
>>> id(x) == id(y)
True
```

最後のid(x) == id(y)という式は、Rと同じで、左辺と右辺が正しければTrue、違っていればFalseを返す二項演算です。上記より、確かにpythonの代入がラベル型であることが分かります。

それでは次に、Copy on modifyが働かないことを確かめましょう。

```python
>>> x = [1,2,3]
>>> y = x
>>> id(x) == id(y)
True
>>> x[1] = 5
>>> x
[1, 5, 3]
>>> y   # yまで変化した!
[1, 5, 3]
>>> id(x) == id(y) # Copy on modifyは起きていない
True
```

上記のように、複数の参照をもつオブジェクトの内容を変更すると、それを参照する全ての変数の内容が変わってしまいます。Rとは違ってPythonはCopy on modifyを行わないからです。

## 変更と代入の違い

Pythonの初学者によくある間違いは、**変数xが参照するオブジェクトの内容を修正する**ということと、**変数xに別のオブジェクトを代入させる・参照させる**(参照を付け直す)という二つの操作を混同するということです。

## 宿題(ホームワーク)

1. 講義で説明したように、Pythonでは、ある特定の範囲に含まれる絶対値の小さな整数については、プログラムの実行中ずっとメモリの中に保持され、何回でも再利用されるようになっています。そのような「再利用される」整数のうち、最も値の小さな整数（これは負の整数）と最も値の大きな整数を答えなさい。自分で調べても構わないし、インターネットで検索しても構わない。
2. Copy on modifyメカニズムの挙動に関して、Rのヴァージョン3系統(ヴァージョン3.5,3.6など)と、ヴァージョン4.0の違いを「参照カウント」もしくは「参照カウンター」などの言葉を用いて説明しなさい。
